<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>The Flowers Are Still Standing</title>
        <link>http://jdpgrailsdev.github.io/blog/</link>
        <atom:link href="http://jdpgrailsdev.github.io/blog//feed.xml" rel="self" type="application/rss+xml" />
        <description>Jonathan Pearlin's Blog</description>
        <language>en-us</language>
        <pubDate>Tue, 23 Sep 2014 07:54:31 -0700</pubDate>
        <lastBuildDate>Tue, 23 Sep 2014 07:54:31 -0700</lastBuildDate>
        <image>
            <url>http://jdpgrailsdev.github.io/blog//img/robot_devil.png</url>
            <title>Jonathan Pearlin's Blog</title>
            <link>http://jdpgrailsdev.github.io/blog/</link>
        </image>
        <item>
            <title>Use Spring to Autodetect and Load JRuby Gem Dependencies</title>
            <link>http://jdpgrailsdev.github.io/blog/2014/09/23/spring_jruby_autodetect_deps.html</link>
            <pubDate>Tue, 23 Sep 2014 00:00:00 -0700</pubDate>
            <guid isPermaLink="false">2014/09/23/spring_jruby_autodetect_deps.html</guid>
            <description>
                    &lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;I decided recently to try to use &lt;a href=&quot;http://jruby.org/&quot; target=&quot;_blank&quot;&gt;JRuby&lt;/a&gt; to help me use Ruby-based libraries as plugins in a Java application.  This is pretty easy to do if your Ruby code makes use
of the stock modules included in &lt;a href=&quot;http://jruby.org/&quot; target=&quot;_blank&quot;&gt;JRuby&lt;/a&gt;.  However, what happens if the Ruby scripts need to access other libraries that typically would be found in external
&lt;a href=&quot;https://rubygems.org/&quot; target=&quot;_blank&quot;&gt;Ruby Gems&lt;/a&gt;?  One answer is to use &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt;, &lt;a href=&quot;http://jruby.org/&quot; target=&quot;_blank&quot;&gt;JRuby&lt;/a&gt; and the &lt;a href=&quot;http://spring.io&quot; target=&quot;_blank&quot;&gt;Spring Framework&lt;/a&gt; to automatically download, package and discover these dependencies at build and runtime.
Another way to put it is that we have three distinct operations that we need to perform in order to get all of this playing nicely together:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;Use &lt;a href=&quot;http://bundler.io/&quot; target=&quot;_blank&quot;&gt;Bundler&lt;/a&gt; to find, download and install all required Ruby modules at build time (&lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; + &lt;a href=&quot;http://jruby.org/&quot; target=&quot;_blank&quot;&gt;JRuby&lt;/a&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Package Ruby modules with Ruby script(s) in JAR file (&lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Auto-discover packaged Ruby modules at runtime and add them to the &quot;load path&quot; of the script that is to be executed (&lt;a href=&quot;http://jruby.org/&quot; target=&quot;_blank&quot;&gt;JRuby&lt;/a&gt; + &lt;a href=&quot;http://spring.io&quot; target=&quot;_blank&quot;&gt;Spring Framework&lt;/a&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Execute the script (&lt;a href=&quot;http://jruby.org/&quot; target=&quot;_blank&quot;&gt;JRuby&lt;/a&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Let&amp;#8217;s start with the first task:  Use &lt;a href=&quot;http://bundler.io/&quot; target=&quot;_blank&quot;&gt;Bundler&lt;/a&gt; to find, download and install all required Ruby modules at build time.  To accomplish this, I decided to
use custom tasks in a &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; script to first install &lt;a href=&quot;http://bundler.io/&quot; target=&quot;_blank&quot;&gt;Bundler&lt;/a&gt; and then use &lt;a href=&quot;http://bundler.io/&quot; target=&quot;_blank&quot;&gt;Bundler&lt;/a&gt; to install any required Ruby modules found in the project&amp;#8217;s &lt;code&gt;Gemfile&lt;/code&gt;.
This &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; script also needed to be able to copy the installed &lt;a href=&quot;https://rubygems.org/&quot; target=&quot;_blank&quot;&gt;Ruby Gems&lt;/a&gt; to a directory that would ensure their inclusion in the packaged JAR file.  Below
is the script:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;import groovy.util.AntBuilder

buildscript {
    dependencies {
        classpath &apos;org.jruby:jruby-complete:1.7.13&apos;
    }
}

jar {
    from (&quot;${project.projectDir}/src/main/ruby&quot;)
}

dependencies {
    runtime project(&apos;:shared&apos;)
}

sourceSets {
    main {
       java {
          srcDir file(&quot;${project.projectDir}/src/main/ruby&quot;)
       }
    }
}

/*
 * Installs Bundler to the project&apos;s build directory.  Bundler is used to
 * install any Gems required by this plugin.
 */
task installBundler(type:JavaExec, description:&apos;Installs Bundler&apos;) {
    args = &quot;--2.0 -S gem install -i ${project.buildDir}/bundler --no-rdoc --no-ri bundler&quot;.tokenize()
    classpath = project.buildscript.configurations.classpath
    jvmArgs(&quot;-Xmx800M&quot;)
    main = &apos;org.jruby.Main&apos;
    environment = [HOME:System.getProperty(&apos;user.home&apos;),
                    PATH:[&apos;/usr/local/bin&apos;, &apos;/usr/bin&apos;,&apos;/bin&apos;,&apos;/usr/sbin&apos;,&apos;/sbin&apos;].join(File.pathSeparator)]
    workingDir = project.projectDir
}

/*
 * Installs the Gems required by this plugin to the project&apos;s build directory.
 * This task uses Bundler to perform the Gem installations.
 */
task installGems(type:JavaExec, description:&apos;Installs all required Gems via Bundle.&apos;, dependsOn:&apos;installBundler&apos;) {
    args = &quot;--2.0 -S bundle install --path ${project.buildDir}&quot;.tokenize()
    classpath = project.buildscript.configurations.classpath
    main = &apos;org.jruby.Main&apos;
    environment = [GEM_PATH: &quot;${project.buildDir}/bundler&quot;,
                    HOME:System.getProperty(&apos;user.home&apos;),
                    PATH:[&quot;${project.buildDir}/bundler/bin&quot;, &apos;/usr/local/bin&apos;, &apos;/usr/bin&apos;,&apos;/bin&apos;,&apos;/usr/sbin&apos;,&apos;/sbin&apos;].join(File.pathSeparator)]
    workingDir = project.projectDir
}

/*
 * Moves the installed Gem files from the project&apos;s build directory to src/main/resources
 * so that they will be included in the packaged JAR.
 */
task packageGems(dependsOn:&apos;installGems&apos;) {
    doLast {
        Properties props = new Properties()
        props.load(new File(&quot;${project.projectDir}/src/main/resources/META-INF/notification/${project.name}.plugin&quot;).newDataInputStream())
        File parent = new File(&quot;${project.projectDir}/src/main/resources/${props.getProperty(&apos;plugin-name&apos;)}/gems&quot;)
        parent.deleteDir()
        parent.mkdirs()

        // Normalize each installed gem directory name and move it to src/main/resources
        new File(&quot;${project.buildDir}/jruby/1.9/gems&quot;).listFiles().each { file -&amp;gt;
            processSourceFiles(parent, new File(file, &apos;lib&apos;))
            File vendorGems = new File(file, &apos;vendor/gems&apos;)
            if(vendorGems.exists()) {
                vendorGems.listFiles().each { vendorFile -&amp;gt;
                    processSourceFiles(parent, new File(vendorFile, &apos;lib&apos;))
                }
            }
        }
    }
}

project.tasks.installGems.inputs.file(&quot;${project.projectDir}/Gemfile&quot;)
project.tasks.installGems.outputs.dir(&quot;${project.buildDir}/jruby&quot;)
project.tasks.installBundler.outputs.upToDateWhen { new File(&quot;${project.buildDir}/bundler&quot;).exists() }
project.tasks.jar.dependsOn([&apos;packageGems&apos;])

def processSourceFiles(File newParent, File rootDir) {
    File newRootDir = new File(newParent, rootDir.getParentFile().getName())
    new AntBuilder().copy(todir : newRootDir.getAbsolutePath(), quiet:true) {
        fileset(dir: rootDir.getAbsolutePath())
    }
    newRootDir.eachFileRecurse { rubyFile -&amp;gt;
        if(rubyFile.isFile() &amp;amp;&amp;amp; rubyFile.text.contains(&apos;require_relative&apos;)) {
            def builder = new StringBuilder()
            rubyFile.eachLine { line -&amp;gt;
                line = line.replaceAll(&apos;require_relative\\s+\&apos;\\.\\/(.+)\&apos;&apos;, &apos;require_relative \&apos;$1\&apos;&apos;)
                def matcher = line =~ /require_relative\s+&apos;((\.\.\/)+).+&apos;/
                if(matcher.find()) {
                    def numberOfParentDirs = matcher[0][1].split(&apos;/&apos;).length
                    def actualParent = rubyFile.getParentFile()
                    numberOfParentDirs.times { actualParent = actualParent.getParentFile() }
                    actualParent = actualParent.getAbsolutePath().minus(&quot;${newRootDir.getAbsolutePath()}/&quot;)
                    line = line.replaceAll(&apos;require_relative\\s+\&apos;(?:\\.\\.\\/)+(.+)\&apos;&apos;, &quot;require &apos;${actualParent ? &quot;${actualParent}/&quot; : actualParent}\$1&apos;&quot;)
                }
                builder.append(line.trim())
                builder.append(&apos;\n&apos;)
            }
            rubyFile.write(builder.toString())
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;A couple of things to point out.  First, the script uses &lt;a href=&quot;http://jruby.org/&quot; target=&quot;_blank&quot;&gt;JRuby&lt;/a&gt; in custom &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; tasks to execute the Ruby-based commands.  Second, the script recursively
walks through each of the installed &lt;a href=&quot;https://rubygems.org/&quot; target=&quot;_blank&quot;&gt;Ruby Gems&lt;/a&gt; to properly normalize any &lt;code&gt;require_relative&lt;/code&gt; statements into absolute paths.  This is necessary as &lt;a href=&quot;http://jruby.org/&quot; target=&quot;_blank&quot;&gt;JRuby&lt;/a&gt; does
not handle relative paths in included &lt;a href=&quot;https://rubygems.org/&quot; target=&quot;_blank&quot;&gt;Ruby Gems&lt;/a&gt; very well (or at all).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;At this point, running &lt;code&gt;./gradlew build&lt;/code&gt; on this project will produce a JAR file containing any Ruby scripts found in &lt;code&gt;src/main/ruby&lt;/code&gt;, as well as any required
&lt;a href=&quot;https://rubygems.org/&quot; target=&quot;_blank&quot;&gt;Ruby Gems&lt;/a&gt; installed by the script.  The next step to use a Ruby-based plugin in a Java application is to use &lt;a href=&quot;http://jruby.org/&quot; target=&quot;_blank&quot;&gt;JRuby&lt;/a&gt; to execute the script.  I&amp;#8217;m not going
to go into all of the details about wiring that up, as the &lt;a href=&quot;http://jruby.org/&quot; target=&quot;_blank&quot;&gt;JRuby&lt;/a&gt; tutorials cover this pretty well.  Instead, I am going to focus on how to extract the
required &lt;a href=&quot;https://rubygems.org/&quot; target=&quot;_blank&quot;&gt;Ruby Gems&lt;/a&gt; that we included in the JAR and make sure that they are available to our Ruby script(s) when &lt;a href=&quot;http://jruby.org/&quot; target=&quot;_blank&quot;&gt;JRuby&lt;/a&gt; executes them.  To accomplish this,
I decided to make use of the &lt;a href=&quot;http://spring.io&quot; target=&quot;_blank&quot;&gt;Spring Framework&lt;/a&gt;&apos;s &lt;code&gt;PathMatchingResourcePatternResolver&lt;/code&gt; to auto-discover the included &lt;a href=&quot;https://rubygems.org/&quot; target=&quot;_blank&quot;&gt;Ruby Gems&lt;/a&gt; and add them to &lt;a href=&quot;http://jruby.org/&quot; target=&quot;_blank&quot;&gt;JRuby&lt;/a&gt;&apos;s load path:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint java language-java&quot;&gt;&lt;code&gt;import java.util.HashSet;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;


import org.jruby.embed.ScriptingContainer;
import org.springframework.core.io.Resource;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;

...

final String pluginName = &quot;test-plugin&quot;;

final PathMatchingResourcePatternResolver patternResolver = new PathMatchingResourcePatternResolver();

final Resource[] dependencyGemResources  = patternResolver.getResources(String.format(&quot;classpath*:/%s/gems/**/*.rb&quot;, pluginName));

final Pattern dependencyGemPattern = Pattern.compile(String.format(&quot;^classpath:\\/%s\\/gems\\/([a-zA-Z\\-\\.0-9_]+)/.*$&quot;, pluginName));

final ScriptingContainer container = new ScriptingContainer();

final Set&amp;lt;String&amp;gt; loadPaths = new HashSet&amp;lt;String&amp;gt;();

// Add the JRuby-provided Ruby 2.0 modules to the load path
loadPaths.add(&quot;classpath:/META-INF/jruby.home/lib/ruby/2.0&quot;);

// Add any required dependency Gems for this plugin to the load path.
for(final Resource resource : dependencyGemResources) {
    final Matcher matcher = dependencyGemPattern.matcher(resource.getURI().toString().replaceAll(&quot;^jar:file:\\/.*\\.jar!(.*)$&quot;, &quot;classpath:$1&quot;));
    if(matcher.find()) {
        final String resourceName = String.format(&quot;classpath:/%s/gems/%s&quot;, pluginName, matcher.group(1));
        if(!loadPaths.contains(resourceName)) {
            loadPaths.add(resourceName);
        }
    }
}

container.setLoadPaths(loadPaths);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The snippet of Java code above makes use of the &lt;code&gt;PathMatchingResourcePatternResolver&lt;/code&gt; from the &lt;a href=&quot;http://spring.io&quot; target=&quot;_blank&quot;&gt;Spring Framework&lt;/a&gt; to scan the classpath and find all &lt;code&gt;.rb&lt;/code&gt; files under the
&lt;code&gt;/&amp;lt;plugin name&amp;gt;/gems&lt;/code&gt; path.  From this list, the URI of each (which is relative to the JAR file) is converted into a classpath-friendly string that &lt;a href=&quot;http://jruby.org/&quot; target=&quot;_blank&quot;&gt;JRuby&lt;/a&gt;
understands and then added to the list of paths for &lt;a href=&quot;http://jruby.org/&quot; target=&quot;_blank&quot;&gt;JRuby&lt;/a&gt; to load prior to execution of the script.  At this point, if a Ruby script is executed via the
&lt;code&gt;ScriptingContainer&lt;/code&gt; with the properly configured load paths, any references to required modules that are packaged in the plugin&amp;#8217;s JAR file will be found and
the script will execute just as if it were run via Ruby.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
            </description>
        </item>
        <item>
            <title>Avoid Hibernate N+1 Problem with Joins in Spring-Data/JPA</title>
            <link>http://jdpgrailsdev.github.io/blog/2014/09/09/spring_data_hibernate_join.html</link>
            <pubDate>Tue, 9 Sep 2014 00:00:00 -0700</pubDate>
            <guid isPermaLink="false">2014/09/09/spring_data_hibernate_join.html</guid>
            <description>
                    &lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;If you have used &lt;a href=&quot;http://hibernate.org&quot; target=&quot;_blank&quot;&gt;Hibernate&lt;/a&gt; as your ORM for any length of time, you have inevitably run into the
&lt;a href=&quot;http://docs.jboss.org/hibernate/orm/3.3/reference/en-US/html/performance.html#performance-fetching-custom&quot; target=&quot;_blank&quot;&gt;N+1 problem&lt;/a&gt;.  This occurs when
&lt;a href=&quot;http://hibernate.org&quot; target=&quot;_blank&quot;&gt;Hibernate&lt;/a&gt; queries an entity that has a collection of children entities that does not use a &lt;code&gt;JOIN&lt;/code&gt; fetch mode to retrieve the children.  The simple solution
when using &lt;a href=&quot;http://hibernate.org&quot; target=&quot;_blank&quot;&gt;Hibernate&lt;/a&gt; directly is to set the &lt;code&gt;FetchMode&lt;/code&gt; to &lt;code&gt;JOIN&lt;/code&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint java language-java&quot;&gt;&lt;code&gt;User user = (User) session.createCriteria(User.class)
                .setFetchMode(&quot;permissions&quot;, FetchMode.JOIN)
                .add( Restrictions.idEq(userId) )
                .uniqueResult();&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;However, if you are using &lt;a href=&quot;http://www.oracle.com/technetwork/java/javaee/tech/persistence-jsp-140049.html&quot; target=&quot;_blank&quot;&gt;JPA&lt;/a&gt; on top of &lt;a href=&quot;http://hibernate.org&quot; target=&quot;_blank&quot;&gt;Hibernate&lt;/a&gt;, there is no way to set the &lt;code&gt;FetchMode&lt;/code&gt; used by &lt;a href=&quot;http://hibernate.org&quot; target=&quot;_blank&quot;&gt;Hibernate&lt;/a&gt; to &lt;code&gt;JOIN&lt;/code&gt;.  In fact, &lt;a href=&quot;http://www.oracle.com/technetwork/java/javaee/tech/persistence-jsp-140049.html&quot; target=&quot;_blank&quot;&gt;JPA&lt;/a&gt; only
supports two types of fetching:  &lt;code&gt;EAGER&lt;/code&gt; and &lt;code&gt;LAZY&lt;/code&gt;.  Luckily, there is another &lt;a href=&quot;http://www.oracle.com/technetwork/java/javaee/tech/persistence-jsp-140049.html&quot; target=&quot;_blank&quot;&gt;JPA&lt;/a&gt; API that can be used to address this problem:  &lt;a href=&quot;http://projects.spring.io/spring-data-jpa/&quot; target=&quot;_blank&quot;&gt;Spring Data JPA&lt;/a&gt;.  The
&lt;a href=&quot;http://projects.spring.io/spring-data-jpa/&quot; target=&quot;_blank&quot;&gt;Spring Data JPA&lt;/a&gt; library provides a &lt;a href=&quot;http://spring.io/blog/2011/04/26/advanced-spring-data-jpa-specifications-and-querydsl/&quot; target=&quot;_blank&quot;&gt;Domain Driven Design Specifications&lt;/a&gt;
API that allows you to control the behavior of the generated query.  This will allow you to tweak things such as the fetch mode to ensure the proper instruction
is passed to &lt;a href=&quot;http://hibernate.org&quot; target=&quot;_blank&quot;&gt;Hibernate&lt;/a&gt; to address the N+1 problem.  I&amp;#8217;m not going to go into a bunch of details on how to use the &lt;code&gt;JpaSpecificationExecutor&lt;/code&gt;, as the &lt;a href=&quot;http://projects.spring.io/spring-data-jpa/&quot; target=&quot;_blank&quot;&gt;Spring Data JPA&lt;/a&gt;
documentation does a pretty good job of covering it.  What is more important is how to control the fetch mode using it:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint java language-java&quot;&gt;&lt;code&gt;final long userId = 1;

final Specification&amp;lt;User&amp;gt; spec = new Specification&amp;lt;User&amp;gt;() {
    @Override
    public Predicate toPredicate(final Root&amp;lt;User&amp;gt; root, final CriteriaQuery&amp;lt;?&amp;gt; query, final CriteriaBuilder cb) {
        query.distinct(true);
        root.fetch(&quot;permissions&quot;, JoinType.LEFT);
        return cb.equal(root.get(&quot;id&quot;), userId);
     }
};

List&amp;lt;User&amp;gt; users = userRepository.findAll(spec);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;There are two important pieces of the example above.  The first is the setting of the &lt;code&gt;distinct&lt;/code&gt; flag on the query to ensure that the proper (unique) results are returned as
a result of the join.  The second is the addition of a &lt;code&gt;fetch&lt;/code&gt; hint to the root entity, telling the specification to perform a left join of the root to the entity mapped
by the &quot;permissions&quot; field of the root entity.  This ensures that &lt;a href=&quot;http://hibernate.org&quot; target=&quot;_blank&quot;&gt;Hibernate&lt;/a&gt; will now perform a join instead of N+1 queries to fetch the root entity and its associated
children.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
            </description>
        </item>
        <item>
            <title>Ensure Order of Task Execution between Gradle Sub-Projects</title>
            <link>http://jdpgrailsdev.github.io/blog/2014/09/02/gradle_subtask_dependson.html</link>
            <pubDate>Tue, 2 Sep 2014 00:00:00 -0700</pubDate>
            <guid isPermaLink="false">2014/09/02/gradle_subtask_dependson.html</guid>
            <description>
                    &lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;One of the great things (IMHO) about &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; is that it does a pretty good job of choosing sane conventions.  That being said, one place that seems to not always
be a great choice is &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt;&apos;s convention to visit sub-projects in alpha-numerical order.  Let&amp;#8217;s say that you have the following project structure:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;root
 |_ A
 |_ B
    |_ C
    |_ D
 |_ E&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Based on the alpha-numerical ordering, you would probably expect &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; to visit the projects in the following order:  A, B, B:C, B:D, E.  However, this is not the case.
&lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; will visit the sub-projects in alpha-numerical order, within each level.  What you end up with is:  A, B, E, B:C, B:D.  Normally, this probably isn&amp;#8217;t a big deal.
This does become a big deal when one of those sub-projects builds a distribution that needs to include output from all of the other sub-projects.  Such is the case when
building a fully-repackaged, executable JAR file with &lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt;.  The repackaged JAR built by the
&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/current/reference/html/build-tool-plugins-gradle-plugin.html&quot; target=&quot;_blank&quot;&gt;Spring Boot Gradle Plugin&lt;/a&gt; includes all dependency JAR files
required to execute the application.  Let&amp;#8217;s suppose in our example above, the sub-project E&amp;#8217;s &lt;code&gt;build.gradle&lt;/code&gt; script includes the following dependency block:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;dependencies {
    compile module(&apos;:A&apos;)
    compile module(&apos;:B:C&apos;)
    compile module(&apos;:B:D&apos;)
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;What we would like to happen is that when we build project &quot;E&quot;, the JAR file should include the JAR&amp;#8217;s produced by building &quot;A&quot;, &quot;B:C&quot;, and &quot;B:D&quot;.  What actually happens is
that only &quot;A&quot;&apos;s JAR gets included, because of the ordering outlined earlier in this post.  The way to correct this behavior and to ensure that all other sub-projects build
their JAR files prior to &quot;E&quot;&apos;s JAR task executing is to add the following to &quot;E&quot;&apos;s &lt;code&gt;build.gradle&lt;/code&gt; script:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;// Ensure that all other JARs are built before the service is packaged.
project.tasks.jar.dependsOn(rootProject.getSubprojects().findAll { subproject -&amp;gt; subproject.name != project.name }.collect { subproject -&amp;gt; &quot;${subproject.getPath()}:build&quot; })&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The logic above finds every other sub-project in the project and adds that sub-project&amp;#8217;s &quot;build&quot; task as a dependency that first must execute before the current project&amp;#8217;s
JAR task can execute.  This ensures that all other projects have built their JAR files before &lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt; can create the re-packaged JAR.  You can apply this same trick to
any other scenario where the execution of tasks in other sub-projects (regardless of depth) must occur before a certain sub-project&amp;#8217;s task(s).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
            </description>
        </item>
        <item>
            <title>Execute Gradle Tasks Based on Other Tasks</title>
            <link>http://jdpgrailsdev.github.io/blog/2014/08/26/gradle_dependent_tasks.html</link>
            <pubDate>Tue, 26 Aug 2014 00:00:00 -0700</pubDate>
            <guid isPermaLink="false">2014/08/26/gradle_dependent_tasks.html</guid>
            <description>
                    &lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;As discussed in a previous post, &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; supports multiple ways to perform incremental builds, such as caching based on task inputs, the use of the
&lt;a href=&quot;http://www.gradle.org/docs/current/javadoc/org/gradle/api/tasks/TaskOutputs.html#upToDateWhen(groovy.lang.Closure)&quot; target=&quot;_blank&quot;&gt;upToDateWhen&lt;/a&gt; closure on a
task&amp;#8217;s outputs or the use of the task&amp;#8217;s &lt;code&gt;onlyIf()&lt;/code&gt; method to control execution, to name a few.  Sometimes, however, you want a task to only execute if another
cachable task has executed.  For instance, maybe you want to create an archive of some generated source, but only if the source has been updated/re-generated.
One such way to do this is to make use of the &lt;a href=&quot;http://www.gradle.org/docs/current/groovydoc/org/gradle/api/Task.html#getDidWork()&quot; target=&quot;_blank&quot;&gt;getDidWork()&lt;/a&gt;
method of the task to determine if the task actually executed or was skipped/up-to-date:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;class CustomTask extends DefaultTask {

    @TaskAction
    void doSomething() {
        if(project.tasks.getByName(&apos;otherTask&apos;).getDidWork()) {
            // Do this task&apos;s work here!
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;By using the &lt;code&gt;getDidWork&lt;/code&gt; method on the other task to determine if it executed, we can avoid having to rely upon the input/output of the task to determine if
the downstream task should execute, thus giving us better control over what triggers the tasks in our project.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
            </description>
        </item>
        <item>
            <title>Gradle, Task Caching, Tests and Jenkins</title>
            <link>http://jdpgrailsdev.github.io/blog/2014/08/19/gradle_tests_jenkins.html</link>
            <pubDate>Tue, 19 Aug 2014 00:00:00 -0700</pubDate>
            <guid isPermaLink="false">2014/08/19/gradle_tests_jenkins.html</guid>
            <description>
                    &lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;One of the nice features of &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; is the task execution caching, which prevent tasks whose inputs/outputs have not changed since the last successful execution from
executing in order to speed up build times.  Sometimes, however this causes issues when integrating your &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; build into other systems.  I ran into one such issue
when building a &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; application from &lt;a href=&quot;http://jenkins-ci.org/&quot; target=&quot;_blank&quot;&gt;Jenkins&lt;/a&gt;.  The &lt;a href=&quot;http://jenkins-ci.org/&quot; target=&quot;_blank&quot;&gt;Jenkins&lt;/a&gt; build job is configured to publish the results of the &lt;code&gt;test&lt;/code&gt; task (the test reports output by &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt;).
It did not occur to me that if I did not invoke the &lt;code&gt;clean&lt;/code&gt; task and let &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; only re-generate the test reports if any of the compiled code had changed (other file changes
to the project would trigger the CI build) that &lt;a href=&quot;http://jenkins-ci.org/&quot; target=&quot;_blank&quot;&gt;Jenkins&lt;/a&gt; would fail the build due to stale test reports.  However, that is exactly what happened:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;BUILD SUCCESSFUL

Total time: 15.323 secs
Build step &apos;Invoke Gradle script&apos; changed build result to SUCCESS
Test reports were found but none of them are new. Did tests run?
For example, /var/jenkins/jobs/test-job/workspace/build/test-results/TEST-com.example.TestSpec.xml is 12 hours 15 minutes old

Build step &apos;Publish JUnit test result report&apos; changed build result to FAILURE
Finished: FAILURE&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;By not cleaning out the previously compiled code, the caching mechanism for the &lt;code&gt;test&lt;/code&gt; task kicked in and left the previous test results in place, as it properly detected that
nothing had changed and therefore is no need to re-run the tests.  However, Jenkins apparently bases its ability to publish the results of the tests based on a timestamp and not
just the presence of the tests results in the directory specified in the job&amp;#8217;s configuration.  One easy fix is to always run the &lt;code&gt;clean&lt;/code&gt; task, but that eliminates a lot of &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt;&apos;s
performance enhancements around only running task incrementally, based on their inputs/outputs.  Another option is to add the &lt;code&gt;--rerun-tasks&lt;/code&gt; option, which effectively does the same
thing as the &lt;code&gt;clean&lt;/code&gt; task, except it doesn&amp;#8217;t remove any artifacts&amp;#8201;&amp;#8212;&amp;#8201;it just simply forces &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; to run each task regardless of the caching status.  Neither of these options really
get us what we want.  One other alternative is to make use of the &lt;code&gt;upToDateWhen&lt;/code&gt; configuration closure on a tasks declared outputs to control caching on a per-task basis:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;    // Always execute the tests -- needed for Jenkins to be happy
    test.outputs.upToDateWhen { false }&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The example above directs &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; to always run the &lt;code&gt;test&lt;/code&gt; task regardless of what the task cache tells &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; about it.  This gives us fine grained control over which tasks
that we want to take advantage of caching and which ones we want to always run.  By adding the one line above to my project&amp;#8217;s &lt;code&gt;build.gradle&lt;/code&gt; script, I was able to make &lt;a href=&quot;http://jenkins-ci.org/&quot; target=&quot;_blank&quot;&gt;Jenkins&lt;/a&gt;
happy with always providing up-to-date unit tests results, regardless of which files (source or otherwise) have changed in my project.  This also means that &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; will take
advantage of task caching for other tasks in the project (such as compilation, packaging, etc), which helps to reduce build time.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
            </description>
        </item>
    </channel>
</rss>
