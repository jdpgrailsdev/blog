<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>The Flowers Are Still Standing</title>
        <link>http://jdpgrailsdev.github.io/blog/</link>
        <atom:link href="http://jdpgrailsdev.github.io/blog//feed.xml" rel="self" type="application/rss+xml" />
        <description>Jonathan Pearlin's Blog</description>
        <language>en-us</language>
        <pubDate>Tue, 2 Sep 2014 10:56:12 -0400</pubDate>
        <lastBuildDate>Tue, 2 Sep 2014 10:56:12 -0400</lastBuildDate>
        <image>
            <url>http://jdpgrailsdev.github.io/blog//img/robot_devil.png</url>
            <title>Jonathan Pearlin's Blog</title>
            <link>http://jdpgrailsdev.github.io/blog/</link>
        </image>
        <item>
            <title>Ensure Order of Task Execution between Gradle Sub-Projects</title>
            <link>http://jdpgrailsdev.github.io/blog/2014/09/02/gradle_subtask_dependson.html</link>
            <pubDate>Tue, 2 Sep 2014 00:00:00 -0400</pubDate>
            <guid isPermaLink="false">2014/09/02/gradle_subtask_dependson.html</guid>
            <description>
                    &lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;One of the great things (IMHO) about &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; is that it does a pretty good job of choosing sane conventions.  That being said, one place that seems to not always
be a great choice is &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt;&apos;s convention to visit sub-projects in alpha-numerical order.  Let&amp;#8217;s say that you have the following project structure:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;root
 |_ A
 |_ B
    |_ C
    |_ D
 |_ E&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Based on the alpha-numerical ordering, you would probably expect &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; to visit the projects in the following order:  A, B, B:C, B:D, E.  However, this is not the case.
&lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; will visit the sub-projects in alpha-numerical order, within each level.  What you end up with is:  A, B, E, B:C, B:D.  Normally, this probably isn&amp;#8217;t a big deal.
This does become a big deal when one of those sub-projects builds a distribution that needs to include output from all of the other sub-projects.  Such is the case when
building a fully-repackaged, executable JAR file with &lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt;.  The repackaged JAR built by the
&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/current/reference/html/build-tool-plugins-gradle-plugin.html&quot; target=&quot;_blank&quot;&gt;Spring Boot Gradle Plugin&lt;/a&gt; includes all dependency JAR files
required to execute the application.  Let&amp;#8217;s suppose in our example above, the sub-project E&amp;#8217;s &lt;code&gt;build.gradle&lt;/code&gt; script includes the following dependency block:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;dependencies {
    compile module(&apos;:A&apos;)
    compile module(&apos;:B:C&apos;)
    compile module(&apos;:B:D&apos;)
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;What we would like to happen is that when we build project &quot;E&quot;, the JAR file should include the JAR&amp;#8217;s produced by building &quot;A&quot;, &quot;B:C&quot;, and &quot;B:D&quot;.  What actually happens is
that only &quot;A&quot;&apos;s JAR gets included, because of the ordering outlined earlier in this post.  The way to correct this behavior and to ensure that all other sub-projects build
their JAR files prior to &quot;E&quot;&apos;s JAR task executing is to add the following to &quot;E&quot;&apos;s &lt;code&gt;build.gradle&lt;/code&gt; script:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;// Ensure that all other JARs are built before the service is packaged.
project.tasks.jar.dependsOn(rootProject.getSubprojects().findAll { subproject -&amp;gt; subproject.name != project.name }.collect { subproject -&amp;gt; &quot;${subproject.getPath()}:build&quot; })&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The logic above finds every other sub-project in the project and adds that sub-project&amp;#8217;s &quot;build&quot; task as a dependency that first must execute before the current project&amp;#8217;s
JAR task can execute.  This ensures that all other projects have built their JAR files before &lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt; can create the re-packaged JAR.  You can apply this same trick to
any other scenario where the execution of tasks in other sub-projects (regardless of depth) must occur before a certain sub-project&amp;#8217;s task(s).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
            </description>
        </item>
        <item>
            <title>Execute Gradle Tasks Based on Other Tasks</title>
            <link>http://jdpgrailsdev.github.io/blog/2014/08/26/gradle_dependent_tasks.html</link>
            <pubDate>Tue, 26 Aug 2014 00:00:00 -0400</pubDate>
            <guid isPermaLink="false">2014/08/26/gradle_dependent_tasks.html</guid>
            <description>
                    &lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;As discussed in a previous post, &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; supports multiple ways to perform incremental builds, such as caching based on task inputs, the use of the
&lt;a href=&quot;http://www.gradle.org/docs/current/javadoc/org/gradle/api/tasks/TaskOutputs.html#upToDateWhen(groovy.lang.Closure)&quot; target=&quot;_blank&quot;&gt;upToDateWhen&lt;/a&gt; closure on a
task&amp;#8217;s outputs or the use of the task&amp;#8217;s &lt;code&gt;onlyIf()&lt;/code&gt; method to control execution, to name a few.  Sometimes, however, you want a task to only execute if another
cachable task has executed.  For instance, maybe you want to create an archive of some generated source, but only if the source has been updated/re-generated.
One such way to do this is to make use of the &lt;a href=&quot;http://www.gradle.org/docs/current/groovydoc/org/gradle/api/Task.html#getDidWork()&quot; target=&quot;_blank&quot;&gt;getDidWork()&lt;/a&gt;
method of the task to determine if the task actually executed or was skipped/up-to-date:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;class CustomTask extends DefaultTask {

    @TaskAction
    void doSomething() {
        if(project.tasks.getByName(&apos;otherTask&apos;).getDidWork()) {
            // Do this task&apos;s work here!
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;By using the &lt;code&gt;getDidWork&lt;/code&gt; method on the other task to determine if it executed, we can avoid having to rely upon the input/output of the task to determine if
the downstream task should execute, thus giving us better control over what triggers the tasks in our project.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
            </description>
        </item>
        <item>
            <title>Gradle, Task Caching, Tests and Jenkins</title>
            <link>http://jdpgrailsdev.github.io/blog/2014/08/19/gradle_tests_jenkins.html</link>
            <pubDate>Tue, 19 Aug 2014 00:00:00 -0400</pubDate>
            <guid isPermaLink="false">2014/08/19/gradle_tests_jenkins.html</guid>
            <description>
                    &lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;One of the nice features of &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; is the task execution caching, which prevent tasks whose inputs/outputs have not changed since the last successful execution from
executing in order to speed up build times.  Sometimes, however this causes issues when integrating your &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; build into other systems.  I ran into one such issue
when building a &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; application from &lt;a href=&quot;http://jenkins-ci.org/&quot; target=&quot;_blank&quot;&gt;Jenkins&lt;/a&gt;.  The &lt;a href=&quot;http://jenkins-ci.org/&quot; target=&quot;_blank&quot;&gt;Jenkins&lt;/a&gt; build job is configured to publish the results of the &lt;code&gt;test&lt;/code&gt; task (the test reports output by &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt;).
It did not occur to me that if I did not invoke the &lt;code&gt;clean&lt;/code&gt; task and let &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; only re-generate the test reports if any of the compiled code had changed (other file changes
to the project would trigger the CI build) that &lt;a href=&quot;http://jenkins-ci.org/&quot; target=&quot;_blank&quot;&gt;Jenkins&lt;/a&gt; would fail the build due to stale test reports.  However, that is exactly what happened:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;BUILD SUCCESSFUL

Total time: 15.323 secs
Build step &apos;Invoke Gradle script&apos; changed build result to SUCCESS
Test reports were found but none of them are new. Did tests run?
For example, /var/jenkins/jobs/test-job/workspace/build/test-results/TEST-com.example.TestSpec.xml is 12 hours 15 minutes old

Build step &apos;Publish JUnit test result report&apos; changed build result to FAILURE
Finished: FAILURE&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;By not cleaning out the previously compiled code, the caching mechanism for the &lt;code&gt;test&lt;/code&gt; task kicked in and left the previous test results in place, as it properly detected that
nothing had changed and therefore is no need to re-run the tests.  However, Jenkins apparently bases its ability to publish the results of the tests based on a timestamp and not
just the presence of the tests results in the directory specified in the job&amp;#8217;s configuration.  One easy fix is to always run the &lt;code&gt;clean&lt;/code&gt; task, but that eliminates a lot of &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt;&apos;s
performance enhancements around only running task incrementally, based on their inputs/outputs.  Another option is to add the &lt;code&gt;--rerun-tasks&lt;/code&gt; option, which effectively does the same
thing as the &lt;code&gt;clean&lt;/code&gt; task, except it doesn&amp;#8217;t remove any artifacts&amp;#8201;&amp;#8212;&amp;#8201;it just simply forces &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; to run each task regardless of the caching status.  Neither of these options really
get us what we want.  One other alternative is to make use of the &lt;code&gt;upToDateWhen&lt;/code&gt; configuration closure on a tasks declared outputs to control caching on a per-task basis:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;    // Always execute the tests -- needed for Jenkins to be happy
    test.outputs.upToDateWhen { false }&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The example above directs &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; to always run the &lt;code&gt;test&lt;/code&gt; task regardless of what the task cache tells &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; about it.  This gives us fine grained control over which tasks
that we want to take advantage of caching and which ones we want to always run.  By adding the one line above to my project&amp;#8217;s &lt;code&gt;build.gradle&lt;/code&gt; script, I was able to make &lt;a href=&quot;http://jenkins-ci.org/&quot; target=&quot;_blank&quot;&gt;Jenkins&lt;/a&gt;
happy with always providing up-to-date unit tests results, regardless of which files (source or otherwise) have changed in my project.  This also means that &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; will take
advantage of task caching for other tasks in the project (such as compilation, packaging, etc), which helps to reduce build time.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
            </description>
        </item>
        <item>
            <title>Dynamically Build JavaExec Classpath from BuildScript Dependencies in Gradle</title>
            <link>http://jdpgrailsdev.github.io/blog/2014/08/12/gradle_javaexec_classpath.html</link>
            <pubDate>Tue, 12 Aug 2014 00:00:00 -0400</pubDate>
            <guid isPermaLink="false">2014/08/12/gradle_javaexec_classpath.html</guid>
            <description>
                    &lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Recently, I have been working on a few &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; plugins that use the &lt;a href=&quot;http://www.gradle.org/docs/current/dsl/org.gradle.api.tasks.JavaExec.html&quot; target=&quot;_blank&quot;&gt;Gradle JavaExec Task&lt;/a&gt;
to execute a Java main class from within the plugin.  This is pretty straightforward and not at all interesting.  However, in testing the plugin, I realized that I did not
want to expose the required dependencies needed to run the main class outside of the plugin.  If I did, I would require each project that applies my plugin to list the
dependencies in its &lt;code&gt;dependencies&lt;/code&gt; block.  This is obviously a leaky abstraction, so I decided to see if I could programmatically set the classpath of the &lt;a href=&quot;http://www.gradle.org/docs/current/dsl/org.gradle.api.tasks.JavaExec.html&quot; target=&quot;_blank&quot;&gt;Gradle JavaExec Task&lt;/a&gt;
to us use the plugin&amp;#8217;s dependencies:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;task generate(type: JavaExec) {
    main = &apos;com.example.Generator&apos;
    args = [&apos;arg1&apos;, &apos;arg2&apos;]
    classpath = buildscript.configurations.classpath
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In the example above, the task&amp;#8217;s classpath is set to the classpath created by the &lt;code&gt;buildscript&lt;/code&gt; DSL, which includes my plugin dependency and all of its transitive dependencies (unless
you disable transitive resolution when you define the plugin dependency).  This worked great until I used my plugin as part of a multi-module project, where the plugin dependency
is declared and applied in the root project, but the task is executed on the sub-project.  What happened is that the above example only loaded the build script classpath for
the current project (the sub-project), which did not have the plugin dependency on its classpath (apparently, the build script classpath is not additive/transitive).  I addressed
this by writing a little recursive function to traverse up the project tree and add the dependencies from each build script:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;task generate(type: JavaExec) {
    main = &apos;com.example.Generator&apos;
    args = [&apos;arg1&apos;, &apos;arg2&apos;]
    classpath = files(getClasspath(project))
}

private List&amp;lt;File&amp;gt; getClasspath(project, classpath=[]) {
    if(project == null || project == project.rootProject) {
        classpath
    } else {
        classpath.addAll(project.buildscript.configurations.classpath.getFiles())
        getClasspath(project.rootProject, classpath)
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The above example starts with the current project, adds its build script dependencies to the classpath and then recursively looks at the project&amp;#8217;s root project.  This continues
until the project does not have a root project or the root project is the project itself.  The result is then converted to a &lt;code&gt;FileCollection&lt;/code&gt; and the classpath is set, ensuring
that the &lt;a href=&quot;http://www.gradle.org/docs/current/dsl/org.gradle.api.tasks.JavaExec.html&quot; target=&quot;_blank&quot;&gt;Gradle JavaExec Task&lt;/a&gt; has the dependencies provided by the custom plugin.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
            </description>
        </item>
        <item>
            <title>Updating to the latest Docker/Boot2Docker version</title>
            <link>http://jdpgrailsdev.github.io/blog/2014/08/05/docker_upgrade.html</link>
            <pubDate>Tue, 5 Aug 2014 00:00:00 -0400</pubDate>
            <guid isPermaLink="false">2014/08/05/docker_upgrade.html</guid>
            <description>
                    &lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Not too long ago, the &lt;a href=&quot;http://www.docker.com/&quot; target=&quot;_blank&quot;&gt;Docker&lt;/a&gt; project released 1.0 release, which among many improvements includes a new default port for &lt;a href=&quot;http://www.docker.com/&quot; target=&quot;_blank&quot;&gt;Docker&lt;/a&gt;.  To update from &lt;a href=&quot;http://www.docker.com/&quot; target=&quot;_blank&quot;&gt;Docker&lt;/a&gt;
 &amp;lt; 1.0 to &lt;a href=&quot;http://www.docker.com/&quot; target=&quot;_blank&quot;&gt;Docker&lt;/a&gt; &amp;gt;= 1.0, you may run into issues as the port that &lt;a href=&quot;http://www.docker.com/&quot; target=&quot;_blank&quot;&gt;Docker&lt;/a&gt; listens on by default has changed from 4243 to 2375.  While things
may appear to start correctly after an upgrade, you may see the following error when attempting to run any &lt;a href=&quot;http://www.docker.com/&quot; target=&quot;_blank&quot;&gt;Docker&lt;/a&gt; client command:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;$ boot2docker up

Cannot connect to the Docker daemon. Is &apos;docker -d&apos; running on this host?&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This is because your &lt;a href=&quot;https://www.virtualbox.org/&quot; target=&quot;_blank&quot;&gt;Virtual Box&lt;/a&gt; &quot;boot2docker-vm&quot; image is still listening on the old port and therefore is not receiving the forwarded commands.  You can verify this by
starting up &lt;a href=&quot;https://github.com/boot2docker/boot2docker&quot; target=&quot;_blank&quot;&gt;Boot2Docker&lt;/a&gt; and ssh&amp;#8217;ing (&lt;code&gt;boot2docker ssh&lt;/code&gt;) into the VM to check the port that docker is listening on:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;docker@boot2docker:~$ sudo netstat -ntpl | grep docker
tcp        0      0 :::4243                :::*                    LISTEN      627/docker&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;To fix this, use the following steps:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;Update to latest &lt;a href=&quot;https://github.com/boot2docker/boot2docker&quot; target=&quot;_blank&quot;&gt;Boot2Docker&lt;/a&gt; and &lt;a href=&quot;http://www.docker.com/&quot; target=&quot;_blank&quot;&gt;Docker&lt;/a&gt; via &lt;a href=&quot;http://brew.sh/&quot; target=&quot;_blank&quot;&gt;Homebrew&lt;/a&gt; (installing &lt;a href=&quot;https://github.com/boot2docker/boot2docker&quot; target=&quot;_blank&quot;&gt;Boot2Docker&lt;/a&gt; will automatically install/update &lt;a href=&quot;http://www.docker.com/&quot; target=&quot;_blank&quot;&gt;Docker&lt;/a&gt; to the corresponding version).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Run &lt;code&gt;boot2docker delete&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Delete the existing &lt;code&gt;~/.boot2docker&lt;/code&gt; directory.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Run &lt;code&gt;boot2docker init&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Open &lt;a href=&quot;https://www.virtualbox.org/&quot; target=&quot;_blank&quot;&gt;Virtual Box&lt;/a&gt;, select the &lt;code&gt;boot2docker-vm&lt;/code&gt; and click on the &quot;Settings&quot; button.&lt;/p&gt;
&lt;div class=&quot;olist loweralpha&quot;&gt;
&lt;ol class=&quot;loweralpha&quot; type=&quot;a&quot;&gt;
&lt;li&gt;
&lt;p&gt;Click on the &quot;Network button&quot; in the settings window, expand the &quot;Advanced&quot; area and click on the &quot;Port Forwarding&quot; button.  Verify that 2375 and 2022 are in the list.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Run &lt;code&gt;boot2docker up&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Run &lt;code&gt;boot2docker ssh&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In the VM, run the following command to verify that &lt;a href=&quot;http://www.docker.com/&quot; target=&quot;_blank&quot;&gt;Docker&lt;/a&gt; is listening on port 2375:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;sudo netstat -ntpl | grep docker

docker@boot2docker:~$ sudo netstat -ntpl | grep docker
tcp        0      0 :::2375                 :::*                    LISTEN      627/docker&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You should now be able to connect to &lt;a href=&quot;http://www.docker.com/&quot; target=&quot;_blank&quot;&gt;Docker&lt;/a&gt; and use the command line client and the REST API!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
            </description>
        </item>
    </channel>
</rss>
