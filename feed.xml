<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>The Flowers Are Still Standing</title>
        <link>http://jdpgrailsdev.github.io/blog/</link>
        <atom:link href="http://jdpgrailsdev.github.io/blog//feed.xml" rel="self" type="application/rss+xml" />
        <description>Jonathan Pearlin's Blog</description>
        <language>en-us</language>
        <pubDate>Tue, 25 Nov 2014 07:54:07 -0800</pubDate>
        <lastBuildDate>Tue, 25 Nov 2014 07:54:07 -0800</lastBuildDate>
        <image>
            <url>http://jdpgrailsdev.github.io/blog//img/robot_devil.png</url>
            <title>Jonathan Pearlin's Blog</title>
            <link>http://jdpgrailsdev.github.io/blog/</link>
        </image>
        <item>
            <title>Execute Functional Tests in a Docker Container with Gradle (Part 2)</title>
            <link>http://jdpgrailsdev.github.io/blog/2014/11/25/functional_tests_gradle_docker_part_ii.html</link>
            <pubDate>Tue, 25 Nov 2014 00:00:00 -0800</pubDate>
            <guid isPermaLink="false">2014/11/25/functional_tests_gradle_docker_part_ii.html</guid>
            <description>
                    &lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In &lt;a href=&quot;http://jdpgrailsdev.github.io/blog/2014/11/18/functional_tests_gradle_docker_part_i.html&quot; target=&quot;_blank&quot;&gt;part one&lt;/a&gt; of this blog post, I discussed how to
build a functional test using &lt;a href=&quot;https://code.google.com/p/spock/&quot; target=&quot;_blank&quot;&gt;Spock&lt;/a&gt; and &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt;.  Normally, this is all that you would need to be able to test the part of your application that relies
on a data source.  However, what can you do if you find yourself in a situation where you do not have access to dependencies or the repositories that provide
them?  The solution is to bundle your tests along with the dependencies and execute them as an application.  In this post, I will discuss how I accomplished
such a solution using &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; and &lt;a href=&quot;https://www.docker.com/&quot; target=&quot;_blank&quot;&gt;Docker&lt;/a&gt;.  First, let&amp;#8217;s look at the &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; build script:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;apply plugin: &apos;groovy&apos;
apply plugin: &apos;jetty&apos;

ext {
    webSourceDir = &quot;$buildDir/www&quot;
    imageName = &quot;${rootProject.name}-functional-tests&quot;
    springVersion = &apos;4.0.7.RELEASE&apos;
}

sourceSets {
    funcTest {
        groovy {
            srcDir file(&apos;src/functionalTest/groovy&apos;)
        }
    }
}

eclipse {
    classpath {
        downloadSources = true
        defaultOutputDir = file(&quot;$buildDir/classes&quot;)
    }
    project {
        name = &quot;${rootProject.name}-functional-tests&quot;
    }
}

eclipseJdt.enabled = false
cleanEclipseJdt.enabled = false

jettyRun {
    httpPort = System.getenv(&apos;PORT&apos;) ? System.getenv(&apos;PORT&apos;) as int : 8080
    contextPath = &apos;status/check&apos;
    webAppSourceDirectory = file(webSourceDir)
}

dependencies {
    compile project(&apos;:app&apos;)		// include the code that is needed to execute the tests (e.g., any entity classes, etc)

    testCompile &apos;junit:junit:4.11&apos;
    testCompile &apos;cglib:cglib-nodep:3.1&apos;
    testCompile &apos;org.objenesis:objenesis:2.1&apos;
    testCompile &apos;org.spockframework:spock-core:0.7-groovy-2.0&apos;
    testCompile &apos;org.spockframework:spock-spring:0.7-groovy-2.0&apos;
    testCompile &quot;org.springframework:spring-test:${springVersion}&quot;

    funcTestCompile sourceSets.main.output
    funcTestCompile configurations.testCompile
    funcTestRuntime configurations.testRuntime
}

task buildDist(type: Tar, group:&apos;Build&apos;, description: &apos;Builds the Tar distribution of the project.&apos;) {
    archiveName = &quot;${rootProject.name}-functional-tests.tar&quot;
    from(&apos;bin&apos;) {
        into(&apos;bin&apos;)
    }
    from(rootProject.projectDir) {
        exclude(&apos;**/build/**&apos;)
        exclude(&apos;**/*.tar&apos;)
        exclude(&apos;**/.gradle/**&apos;)
    }
}

task funcTest(type: Test, group:&apos;Verification&apos;, description: &apos;Runs the functional tests.&apos;) {
    testClassesDir = sourceSets.funcTest.output.classesDir
    classpath = sourceSets.funcTest.runtimeClasspath
    jvmArgs = [&apos;-Duser.timezone=UTC&apos;]
    environment = [:] // any necessary env vars for the test
}

task resolveDependencies {
    doLast {
        project.rootProject.allprojects.each { subProject -&amp;gt;
            subProject.buildscript.configurations.each { configuration -&amp;gt;
                configuration.resolve()
            }
            subProject.configurations.each { configuration -&amp;gt;
                configuration.resolve()
            }
        }
    }
}

task createWebSourceDir {
    doLast {
        new File(webSourceDir).mkdirs()
    }
}

task collectTestResults(type:Tar, group:&apos;Verification&apos;, dependsOn:[&apos;createWebSourceDir&apos;, &apos;funcTest&apos;], description: &apos;Generates a tarball of the collected test report.&apos;) {
    archiveName = &apos;functional-test-reports.tar&apos;
    destinationDir = file(webSourceDir)
    from(&quot;$buildDir/reports/tests&quot;) {
        into(&apos;reports/tests&apos;)
    }
    from(&quot;$buildDir/test-results&quot;) {
        into(&apos;test-results&apos;)
    }
}

task execute(dependsOn:[&apos;jettyRun&apos;])

/*
 * Ensure that the tests are always executed
 */
project.tasks.collectTestResults.outputs.upToDateWhen { false }
project.tasks.funcTest.outputs.upToDateWhen { false }
project.tasks.resolveDependencies.outputs.upToDateWhen { false }
build.finalizedBy(project.tasks.buildDist)
project.tasks.buildDist.dependsOn([&apos;build&apos;])
project.tasks.jettyRun.dependsOn([&apos;collectTestResults&apos;])&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The script above has three very interesting parts:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A custom &lt;code&gt;test&lt;/code&gt; task that runs all of the functional tests defined by the &lt;code&gt;funcTest&lt;/code&gt; configuration.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The inclusion of the &lt;a href=&quot;http://www.gradle.org/docs/current/userguide/jetty_plugin.html&quot; target=&quot;_blank&quot;&gt;Gradle Jetty Plugin&lt;/a&gt; to expose the test reports.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A custom task (&lt;code&gt;resolveDependencies&lt;/code&gt;) that will ensure that all the required dependencies are resolved and included when building the &lt;a href=&quot;https://www.docker.com/&quot; target=&quot;_blank&quot;&gt;Docker&lt;/a&gt; image.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Now let&amp;#8217;s look at the &lt;code&gt;Dockerfile&lt;/code&gt; for the functional tests before tying it all together.  Below is a simple &lt;code&gt;Dockerfile&lt;/code&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;FROM registry.hub.docker.com/your-base-image:latest

# Install the functional tests
RUN mkdir /var/tests
ADD build/distributions/my-functional-tests.tar /var/tests
RUN chmod +x /var/tests/bin/functional-tests.sh

# Force Gradle to download all of its dependencies at image build time!
RUN rm -rf /root/.gradle
RUN cd /var/tests &amp;amp;&amp;amp; ./gradlew --refresh-dependencies resolveDependencies &amp;gt; /dev/null

EXPOSE 8080
CMD [&quot;cd /var/tests &amp;amp;&amp;amp; ./gradlew --offline clean execute&quot;]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The &lt;code&gt;Dockerfile&lt;/code&gt; extracts the contents of the TAR into the &lt;code&gt;/var/tests&lt;/code&gt; folder inside the &lt;a href=&quot;https://www.docker.com/&quot; target=&quot;_blank&quot;&gt;Docker&lt;/a&gt; image.  Once extracted, the &lt;code&gt;Dockerfile&lt;/code&gt; also invokes the &lt;code&gt;resolveDepednencies&lt;/code&gt; custom task
that we saw in the &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; build script above.  Because the &lt;a href=&quot;https://www.docker.com/&quot; target=&quot;_blank&quot;&gt;Docker&lt;/a&gt; image is being built on a machine that has access to our dependency repositories, it can resolve
everything needed at image creation time.  By resolving the dependencies at this point, we guarantee that the dependencies have been downloaded and cached by &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; inside of the
&lt;a href=&quot;https://www.docker.com/&quot; target=&quot;_blank&quot;&gt;Docker&lt;/a&gt; image.  The final piece of the puzzle is the &lt;code&gt;CMD&lt;/code&gt; directive, which runs the custom &lt;code&gt;execute&lt;/code&gt; task from the &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; build script.  As we saw above, the &lt;code&gt;execute&lt;/code&gt; task launches Jetty, which in turn
launches the functional tests via the &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; task dependency set up in the script.  Upon successful completion of the tests, the test reports generated by &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; are exposed by Jetty so that they can be
viewed/copied/etc.  By tying all of these pieces together, we have created a stand-alone &lt;a href=&quot;https://www.docker.com/&quot; target=&quot;_blank&quot;&gt;Docker&lt;/a&gt; image capable of executing functional tests
using &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; in an environment that does not have the ability to resolve dependencies!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
            </description>
        </item>
        <item>
            <title>Execute Functional Tests in a Docker Container with Gradle (Part 1)</title>
            <link>http://jdpgrailsdev.github.io/blog/2014/11/18/functional_tests_gradle_docker_part_i.html</link>
            <pubDate>Tue, 18 Nov 2014 00:00:00 -0800</pubDate>
            <guid isPermaLink="false">2014/11/18/functional_tests_gradle_docker_part_i.html</guid>
            <description>
                    &lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;One of the applications that I have been working on recently has a lot of complex SQL queries that cannot be tested very well with traditional unit tests.  To fill this gap, we
decided to write a functional test suite that would perform the following steps:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Persist a bunch of data to the table(s) that are used by the query under test to an actual database instance.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Execute the query under test against an actual database instance.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Verify the expected results.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Clean down the table(s) used in the test to avoid pollution against other tests.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The application(s) under test are &lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt; applications, which make use of &lt;a href=&quot;http://projects.spring.io/spring-data-jpa/&quot; target=&quot;_blank&quot;&gt;Spring Data JPA&lt;/a&gt; for the presistence layer.  Below is an example of one of the repositories:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint java language-java&quot;&gt;&lt;code&gt;@Repository
public interface BookRepository extends JpaRepository&amp;lt;Book, Long&amp;gt; {

    List&amp;lt;Book&amp;gt; findByIsbn(final String isbn);

}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Writing a functional test for just such a repository is pretty easy using &lt;a href=&quot;https://code.google.com/p/spock/&quot; target=&quot;_blank&quot;&gt;Spock&lt;/a&gt; and its built-in &lt;a href=&quot;https://code.google.com/p/spock/wiki/SpringExtension&quot; target=&quot;_blank&quot;&gt;Spring extension&lt;/a&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;@ActiveProfiles(&apos;test&apos;)
@ContextConfiguration(classes=[PersistenceConfiguration], loader=SpringApplicationContextLoader)
class BookRepositoryFunctionalSpec extends Specification {

    @Autowired
    private BookRepository boolRepository

    def cleanup() {
        bookRepository.deleteAll()
    }

    def &quot;test that the correct number of books are found when finding books by ISBN&quot;() {
        setup:
            Book book1 = new Book(title:&apos;A Good Book&apos;, author:&apos;Some Guy&apos;, isbn:&apos;978-3-16-148410-0&apos;)
            Book book2 = new Book(title:&apos;A Good Book, Second Edition&apos;, author:&apos;Some Guy&apos;, isbn:&apos;978-3-16-148410-1&apos;)

            bookRepository.saveAndFlush(book1)
            bookRepository.saveAndFlush(book2)
        when:
            def books = bookRepository.findByIsbn(&apos;978-3-16-148410-0&apos;)
        then:
            books != null
            books.size() == 1
            books.first() == book1
        when:
            books = bookRepository.findByIsbn(&apos;unknown&apos;)
        then:
            books != null
            books.size() == 0
    }&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The example &lt;a href=&quot;https://code.google.com/p/spock/&quot; target=&quot;_blank&quot;&gt;Spock&lt;/a&gt; specification above uses the &lt;code&gt;ActiveProfiles&lt;/code&gt; and &lt;code&gt;ContextCongifuration&lt;/code&gt; annotations to load the Spring configuration for use by the test.  This configuration contains
all of the beans required by &lt;a href=&quot;http://projects.spring.io/spring-data-jpa/&quot; target=&quot;_blank&quot;&gt;Spring Data JPA&lt;/a&gt; to connect to the database (data source, entity manager, etc). With the Spring configuration added to the test, we can now make use of Spring
techniques, such as the auto-wiring of dependencies into the specification.  In the example above, we have auto-wired in the &lt;code&gt;BookRepository&lt;/code&gt; that defines the query that we want to test.
The next thing to notice is that the test uses the &lt;code&gt;deleteAll&lt;/code&gt; method of the repository instance to remove any data in the table mapped by the &lt;code&gt;Book&lt;/code&gt; entity after each test in the
specification.  Finally, we have the test itself, which performs the following steps:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Create a couple of &lt;code&gt;Book&lt;/code&gt; entities and persist them to the mapped table using the repository.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Execute the finder method from the repository and validate the correct results are found.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Execute the finder method again, this time with input that should not produce a result to validate what is returned in that scenario.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Note that this could easily be broken up into two tests or refactored to use &lt;a href=&quot;https://code.google.com/p/spock/&quot; target=&quot;_blank&quot;&gt;Spock&lt;/a&gt;&apos;s &lt;code&gt;@Unroll&lt;/code&gt; annotation.  Now that I was armed with a way to build out functional tests against the actual database
using &lt;a href=&quot;http://projects.spring.io/spring-data-jpa/&quot; target=&quot;_blank&quot;&gt;Spring Data JPA&lt;/a&gt; and &lt;a href=&quot;https://code.google.com/p/spock/&quot; target=&quot;_blank&quot;&gt;Spock&lt;/a&gt;, I needed a way to execute the tests.  My first thought was to use &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; to run the tests.  However, due to a limitation of our build infrastructure (our deployment
server does not have access to our artifact repository), &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; would not be able to run the tests, as the build script would not have access to the dependencies it needs to execute!  In the part two of
this blog post, I will take a look at how I overcame this issue by executing the test suite inside of a &lt;a href=&quot;https://www.docker.com/&quot; target=&quot;_blank&quot;&gt;Docker&lt;/a&gt; container using &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
            </description>
        </item>
        <item>
            <title>Auto Configure Health Indicators in Spring Boot</title>
            <link>http://jdpgrailsdev.github.io/blog/2014/11/11/spring_boot_health_indicators_auto_config.html</link>
            <pubDate>Tue, 11 Nov 2014 00:00:00 -0800</pubDate>
            <guid isPermaLink="false">2014/11/11/spring_boot_health_indicators_auto_config.html</guid>
            <description>
                    &lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Another great feature provided by &lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt; is the ability to expose &lt;a href=&quot;http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#production-ready-health&quot; target=&quot;_blank&quot;&gt;Spring Boot Custom Health Information&lt;/a&gt; about your application with very little effort.  The simple approach is to
implement the &lt;code&gt;HealthIndicator&lt;/code&gt; interface and register your custom indicator as a Spring bean (or have it be &lt;a href=&quot;http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/annotation/ComponentScan.html&quot; target=&quot;_blank&quot;&gt;component scanned&lt;/a&gt;).
This is great for one-off indicators or in small projects.  But what happens when you want to have a common set of health indicators that you can use in all of your services (after all, one of the
promises of &lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt; is that it makes it trivial to spin up new &quot;micro&quot; services)?  What do you do if not all of your services have the same components that need to be part of your suite of health indicators?  The solution
is to leverage the &lt;a href=&quot;http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#getting-started-first-application-auto-configuration&quot; target=&quot;_blank&quot;&gt;auto configuration&lt;/a&gt; infrastructure provided by &lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt;.  The first step
is to include the proper dependencies in your health indicator shared library:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;ext {
    springBootVersion = &apos;1.1.8.RELEASE&apos;
}

dependencies {
    compile &quot;org.springframework.boot:spring-boot-autoconfigure:${springBootVersion}&quot;
    compile &quot;org.springframework.boot:spring-boot-actuator:${springBootVersion}&quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The &lt;code&gt;spring-boot-autoconfigure&lt;/code&gt; dependency provides the annotations that we will use to mark our configuration as able to partake in auto configuration.  The &lt;code&gt;spring-boot-actuator&lt;/code&gt;
dependency provides the &lt;code&gt;HealthIndicator&lt;/code&gt; interface and other related classes needed to implement the health indicators.  The next step is to create a custom health indicator implementation:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint java language-java&quot;&gt;&lt;code&gt;import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.util.concurrent.TimeUnit;

import kafka.consumer.ConsumerConfig;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.actuate.health.Health;
import org.springframework.boot.actuate.health.HealthIndicator;

public class KafkaConsumerHealthIndicator implements HealthIndicator {

    private static final Logger log = LoggerFactory.getLogger(KafkaConsumerHealthIndicator.class);

    private final static Long TIMEOUT = TimeUnit.SECONDS.toMillis(3);

    private final String host;

    private final int port;

    public KafkaConsumerHealthIndicator(final ConsumerConfig consumerConfig) {
        this.host = consumerConfig.zkConnect().split(&quot;:&quot;)[0];
        this.port = Integer.valueOf(consumerConfig.zkConnect().split(&quot;:&quot;)[1]);
    }

    @Override
    public Health health() {
        Socket socket = null;

        try {
            socket = new Socket();
            socket.connect(new InetSocketAddress(host, port), TIMEOUT.intValue());
            return Health.up().build();
        } catch (final Exception e) {
            return Health.down(e).build();
        } finally {
            if (socket != null) {
                try {
                    socket.close();
                } catch (final IOException e) {
                    log.debug(&quot;Unable to close Kafka consumer socket.&quot;, e);
                }
            }
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In this example, the health indicator attempts to make a socket connection to the connection string provided by the Kafka &lt;code&gt;ConsumerConfig&lt;/code&gt;.  It&amp;#8217;s a simple test to see if
ZooKeeper is listening at the configured host/port.  The next step is to create an automatic configuration that will define and register this health indicator if the
presence of a bean of type &lt;code&gt;ConsumerConfig&lt;/code&gt; is detected:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint java language-java&quot;&gt;&lt;code&gt;import java.util.Map;

import kafka.consumer.ConsumerConfig;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.actuate.autoconfigure.EndpointAutoConfiguration;
import org.springframework.boot.actuate.autoconfigure.HealthIndicatorAutoConfiguration;
import org.springframework.boot.actuate.health.CompositeHealthIndicator;
import org.springframework.boot.actuate.health.HealthAggregator;
import org.springframework.boot.actuate.health.HealthIndicator;
import org.springframework.boot.autoconfigure.AutoConfigureAfter;
import org.springframework.boot.autoconfigure.AutoConfigureBefore;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
import org.springframework.boot.autoconfigure.condition.ConditionalOnExpression;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@AutoConfigureBefore({ EndpointAutoConfiguration.class })
@AutoConfigureAfter({ HealthIndicatorAutoConfiguration.class })
public class CustomHealthIndicatorAutoConfiguration {

    /**
     * Configuration for Kafka consumer health indicators.
     *
     * @author jpearlin
     * @since 1.0.0
     */
    @Configuration
    @ConditionalOnBean(ConsumerConfig.class)
    @ConditionalOnExpression(&quot;${health.kafka.consumer.enabled:true}&quot;)
    public static class KafkaConsumerHealthIndicatorConfiguration {

        @Autowired
        private HealthAggregator healthAggregator;

        @Autowired(required = false)
        private Map&amp;lt;String, ConsumerConfig&amp;gt; consumerConfigs;

        @Bean
        @ConditionalOnMissingBean(name = &quot;kafkaConsumerHealthIndicator&quot;)
        public HealthIndicator kafkaConsumerHealthIndicator() {
            if (this.consumerConfigs.size() == 1) {
                return new KafkaConsumerHealthIndicator(this.consumerConfigs.values().iterator().next());
            }

            final CompositeHealthIndicator composite = new CompositeHealthIndicator(this.healthAggregator);
            for (final Map.Entry&amp;lt;String, ConsumerConfig&amp;gt; entry : this.consumerConfigs.entrySet()) {
                composite.addHealthIndicator(entry.getKey(), new KafkaConsumerHealthIndicator(entry.getValue()));
            }
            return composite;
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This auto configuration ensures that it is enabled after the default &lt;code&gt;HealthIndicatorAutoConfiguration&lt;/code&gt; provided by the &lt;code&gt;spring-boot-actuator&lt;/code&gt; dependency has been
loaded.  It also defines one Spring &lt;code&gt;Configuration&lt;/code&gt; that is conditionally loaded based on the presence of a bean of type &lt;code&gt;ConsumerConfig&lt;/code&gt;.  It can also be manually
disabled by setting the &lt;code&gt;health.kafka.consumer.enabled&lt;/code&gt; property to &lt;code&gt;false&lt;/code&gt;.  The configuration also ensures that if more than one bean of type &lt;code&gt;ConsumerConfig&lt;/code&gt; is
present, a &lt;code&gt;CompositeHealthIndicator&lt;/code&gt; is created.  The final piece required to tie all of this together is to provide Spring with the required metadata file that
instructs it on which classes represent auto-configuration.  To do this, create a file named &lt;code&gt;spring.factories&lt;/code&gt; in the &lt;code&gt;src/main/resources/META-INF&lt;/code&gt; directory of
your shared health indicator library:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.example.health.autoconfigure.CustomHealthIndicatorAutoConfiguration&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt; will automatically scan for these metadata files when your application starts and register your custom auto configuration class to be enacted if it detects
the &lt;code&gt;EnableAutoConfiguration&lt;/code&gt; annotation on any of your Java-based configuration classes.  Now you can provide a full suite of health indicators that will be enabled if
and only if certain conditions are met, as defined by the various configurations provided by your auto-configuration class!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
            </description>
        </item>
        <item>
            <title>Use connection parameters in Groovy with URL getText()</title>
            <link>http://jdpgrailsdev.github.io/blog/2014/11/04/groovy_url_text_params.html</link>
            <pubDate>Tue, 4 Nov 2014 00:00:00 -0800</pubDate>
            <guid isPermaLink="false">2014/11/04/groovy_url_text_params.html</guid>
            <description>
                    &lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;A while back, I wrote a &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; plugin that would query the &lt;a href=&quot;http://maven.apache.org/&quot; target=&quot;_blank&quot;&gt;Maven&lt;/a&gt; metadata for an artifact in order to automatically determine the next version number
for a sub-model artifact in a project.  To do so, I used the following code to retrieve and parse the &lt;a href=&quot;http://maven.apache.org/&quot; target=&quot;_blank&quot;&gt;Maven&lt;/a&gt; XML metadata:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;String url = &quot;${repository.url}/${project.group.replaceAll(&apos;\\.&apos;,&apos;/&apos;)}/${getProjectName(project)}/maven-metadata.xml&quot;
GPathResult metadata = xmlSlurper.parseText(url.toURL().text)
latestReleaseVersion = metadata.versioning.release&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The above code works great, until you run it in a scenario where you cannot connect to the URL provided by the repository.  When this happens, the code
waits a long time to determine that the connection cannot be established (as it is using the &lt;code&gt;URL&lt;/code&gt; defaults provided by Java for the connection and read
timeouts).  To make this fail faster in the scenarios, I followed some pointers provided by &lt;a href=&quot;http://mrhaki.blogspot.com/2011/09/groovy-goodness-use-connection.html&quot; target=&quot;_blank&quot;&gt;Mr. Haki&lt;/a&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;String url = &quot;${repository.url}/${project.group.replaceAll(&apos;\\.&apos;,&apos;/&apos;)}/${getProjectName(project)}/maven-metadata.xml&quot;
GPathResult metadata = xmlSlurper.parseText(url.toURL().getText(connectTimetout: TimeUnit.SECONDS.toMillis(10), readTimeout: TimeUnit.SECONDS.toMillis(60))))
latestReleaseVersion = metadata.versioning.release&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;As of &lt;a href=&quot;http://groovy.codehaus.org/&quot; target=&quot;_blank&quot;&gt;Groovy&lt;/a&gt; 1.8.1, you can pass the underlying &lt;code&gt;URLConnection&lt;/code&gt;&apos;s parameters to the &lt;code&gt;getText&lt;/code&gt; method.  In the example above, we have passed both the &lt;code&gt;connectTimeout&lt;/code&gt;
and &lt;code&gt;readTimeout&lt;/code&gt; to the &lt;code&gt;getText&lt;/code&gt; method to control when the connection will give up.  This ensures that the code will now fail faster in those offline scenarios.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
            </description>
        </item>
        <item>
            <title>Gradle Task to Resolve (Download) All Configured Dependencies</title>
            <link>http://jdpgrailsdev.github.io/blog/2014/10/28/gradle_resolve_all_dependencies.html</link>
            <pubDate>Tue, 28 Oct 2014 00:00:00 -0700</pubDate>
            <guid isPermaLink="false">2014/10/28/gradle_resolve_all_dependencies.html</guid>
            <description>
                    &lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;I had a challenge recently that involved being able to run a set of &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; tasks in a &lt;a href=&quot;https://www.docker.com/&quot; target=&quot;_blank&quot;&gt;Docker&lt;/a&gt; container that
did not have access to my artifact repository.  The obvious solution is to use the &lt;code&gt;--offline&lt;/code&gt; switch provided
by &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt;, but this only works if you have all the artifacts need to run cached locally.  When &lt;a href=&quot;https://www.docker.com/&quot; target=&quot;_blank&quot;&gt;Docker&lt;/a&gt;
builds its container, you can run any number of commands to populate it with whatever you need.  I decided to
create a simple &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; task to walk through each project in the source that I had copied into the &lt;a href=&quot;https://www.docker.com/&quot; target=&quot;_blank&quot;&gt;Docker&lt;/a&gt;
container that would force resolve each declared dependency:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;task resolveDependencies {
    doLast {
        project.rootProject.allprojects.each { subProject -&amp;gt;
            subProject.buildscript.configurations.each { configuration -&amp;gt;
                configuration.resolve()
            }
            subProject.configurations.each { configuration -&amp;gt;
                configuration.resolve()
            }
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; task above walks through each configuration defined in each sub-project in the &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; project and forces
&lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; to &quot;resolve&quot; (download) the artifacts.  Because it uses the &lt;code&gt;rootProject&lt;/code&gt;, this task can be defined in any
of the sub-projects.  After running this task, the &lt;a href=&quot;https://www.docker.com/&quot; target=&quot;_blank&quot;&gt;Docker&lt;/a&gt; container now has a primed &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; cache that allows me
to run the task in the container in offline mode!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
            </description>
        </item>
    </channel>
</rss>
