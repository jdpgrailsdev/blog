<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>The Flowers Are Still Standing</title>
        <link>http://jdpgrailsdev.github.io/blog/</link>
        <atom:link href="http://jdpgrailsdev.github.io/blog//feed.xml" rel="self" type="application/rss+xml" />
        <description>Jonathan Pearlin's Blog</description>
        <language>en-us</language>
        <pubDate>Tue, 30 Dec 2014 07:51:55 -0800</pubDate>
        <lastBuildDate>Tue, 30 Dec 2014 07:51:55 -0800</lastBuildDate>
        <image>
            <url>http://jdpgrailsdev.github.io/blog//img/robot_devil.png</url>
            <title>Jonathan Pearlin's Blog</title>
            <link>http://jdpgrailsdev.github.io/blog/</link>
        </image>
        <item>
            <title>Leverage Spring Boot&amp;#8217;s YAML Configuration Files in Groovy Scripts</title>
            <link>http://jdpgrailsdev.github.io/blog/2014/12/30/groovy_script_spring_boot_yaml.html</link>
            <pubDate>Tue, 30 Dec 2014 00:00:00 -0800</pubDate>
            <guid isPermaLink="false">2014/12/30/groovy_script_spring_boot_yaml.html</guid>
            <description>
                    &lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In a &lt;a href=&quot;http://jdpgrailsdev.github.io/blog/2014/12/16/spring_context_groovy_script.html&quot; target=&quot;_blank&quot;&gt;previous&lt;/a&gt; blog post, I discussed how to load
an application&amp;#8217;s &lt;a href=&quot;http://projects.spring.io/spring-framework/&quot; target=&quot;_blank&quot;&gt;Spring Framework&lt;/a&gt; configuration in a &lt;a href=&quot;http://groovy.codehaus.org/&quot; target=&quot;_blank&quot;&gt;Groovy&lt;/a&gt; script.  This is a great way to test portions of your application without running the
entire application.  However, this approach has limits.  When trying this with a &lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt; application, you miss out on a bunch of the magical
auto-enabling done by &lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt;.  This includes the ability of &lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt; to find certain properties and configuration files and load their
contents for use by &lt;a href=&quot;http://projects.spring.io/spring-framework/&quot; target=&quot;_blank&quot;&gt;Spring Framework&lt;/a&gt;&apos;s property placeholder mechanism.  In this post, I&amp;#8217;ll discuss how to include a little extra &lt;a href=&quot;http://groovy.codehaus.org/&quot; target=&quot;_blank&quot;&gt;Groovy&lt;/a&gt; sauce to get the
&lt;a href=&quot;http://projects.spring.io/spring-framework/&quot; target=&quot;_blank&quot;&gt;Spring Framework&lt;/a&gt; context to load a YAML file from the classpath and use its values for property placeholder replacement.  Let&amp;#8217;s start by looking at how
to tell the &lt;a href=&quot;http://projects.spring.io/spring-framework/&quot; target=&quot;_blank&quot;&gt;Spring Framework&lt;/a&gt; context how to load the YAML file:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;class YamlMapPropertySourceLoader extends YamlPropertySourceLoader {

    @Override
    public PropertySource load(String name, Resource resource, String profile) throws IOException {
        if (ClassUtils.isPresent(Yaml.class.name, null)) {
            final YamlMapFactoryBean bean = new YamlMapFactoryBean();
            YamlMapFactoryBean factory = new YamlMapFactoryBean()
            factory.setDocumentMatchers(new DefaultProfileDocumentMatcher(), new SpringProfileDocumentMatcher(profile))
            factory.setResolutionMethod(ResolutionMethod.OVERRIDE)
            factory.setResources([resource] as Resource[])
            return new MapPropertySource(name, factory.getObject())
        }
        null
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The code above defines a new &lt;code&gt;PropertySourceLoader&lt;/code&gt; class that produces a &lt;code&gt;PropertySource&lt;/code&gt; wrapping the loaded YAML file.  This bean is responsible for reading
in the contents of the &lt;code&gt;Resource&lt;/code&gt; that contains the YAML file loaded from the classpath and converting those values to a &lt;code&gt;Map&lt;/code&gt; that can be used
by the property placeholder resolver.  You may notice that it checks to see the &lt;a href=&quot;https://code.google.com/p/snakeyaml/&quot; target=&quot;_blank&quot;&gt;Snakeyaml&lt;/a&gt; library is on the classpath.  This code is a copy of
the code found in the &lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt; &lt;code&gt;YamlPropertySourceLoader&lt;/code&gt;, with a small tweak to use the &lt;code&gt;YamlMapFactoryBean&lt;/code&gt; instead of the &lt;code&gt;YamlPropertiesFactoryBean&lt;/code&gt;
(more on this in a bit).  The next step is to create a new Java-based configuration class to register the new &lt;code&gt;YamlMapPropertySourceLoader&lt;/code&gt; with the &lt;a href=&quot;http://projects.spring.io/spring-framework/&quot; target=&quot;_blank&quot;&gt;Spring Framework&lt;/a&gt;
context:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;@Configuration
@Order(Ordered.HIGHEST_PRECEDENCE)
class YamlConfiguration {

    @Bean
    public static EnvironmentAwarePropertySourcesPlaceholderConfigurer propertySourcesPlaceholderConfigurer(PropertySource yamlPropertySourceLoader) {
        MutablePropertySources propertySources = new MutablePropertySources()
        propertySources.addFirst(yamlPropertySourceLoader)

        EnvironmentAwarePropertySourcesPlaceholderConfigurer configurer = new EnvironmentAwarePropertySourcesPlaceholderConfigurer()
        configurer.propertySources = propertySources
        configurer
    }

    @Bean
    public PropertySource yamlPropertySourceLoader() throws IOException {
      YamlMapPropertySourceLoader loader = new YamlMapPropertySourceLoader()
      PropertySource applicationYamlPropertySource = loader.load(&apos;application.yml&apos;, new ClassPathResource(&apos;application.yml&apos;, getClass()), &apos;integration&apos;)
      applicationYamlPropertySource
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The configuration above creates two beans:  one to enable the resolving of property placeholders based on the active profile and another to
actually find and load the YAML configuration file from the classpath.  The special &lt;code&gt;PropertySourcePlaceholderConfiguration&lt;/code&gt; is necessary to make
sure that the configuration loaded from the classpath is added to the &lt;a href=&quot;http://projects.spring.io/spring-framework/&quot; target=&quot;_blank&quot;&gt;Spring Framework&lt;/a&gt; framework context.  Otherwise, simply provided the loader is not
enough to expose the loaded data to the context.  This custom class provides a mechanism to merge the newly found and created property source with those
provided by &lt;a href=&quot;http://projects.spring.io/spring-framework/&quot; target=&quot;_blank&quot;&gt;Spring Framework&lt;/a&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;class EnvironmentAwarePropertySourcesPlaceholderConfigurer extends PropertySourcesPlaceholderConfigurer implements EnvironmentAware, InitializingBean {

    MutablePropertySources propertySources
    Environment environment

    @Override
    public void setEnvironment(Environment environment) {
        this.environment = environment
        super.setEnvironment(environment)
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        def envPropertySources = environment.getPropertySources()
        propertySources.each { propertySource -&amp;gt;
            envPropertySources.addFirst(propertySource)
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The custom configurer uses the loaded YAML property source and the configured &lt;code&gt;Environment&lt;/code&gt; to create a combined set of property sources that can be used for property placeholder replacement.
Once you have this new configuration class in place, you need to register it with the &lt;a href=&quot;http://projects.spring.io/spring-framework/&quot; target=&quot;_blank&quot;&gt;Spring Framework&lt;/a&gt; context:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;...
ctx.register(YamlConfiguration)
ctx.refresh()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;After wiring all of this together and running the &lt;a href=&quot;http://groovy.codehaus.org/&quot; target=&quot;_blank&quot;&gt;Groovy&lt;/a&gt; script, I noticed that the script was upset with some, but not all, of the property placeholders.  After some digging around, I noticed
that it was having issues with finding nested values in the YAML configuration.  For instance, let&amp;#8217;s say you have the following YAML configuration file:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;service:
    host.url: &apos;localhost&apos;
settings:
    timeout: 30
    connection.timeout = 100
debug: false&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You would expect to be able to do something like this using the &lt;a href=&quot;http://projects.spring.io/spring-framework/&quot; target=&quot;_blank&quot;&gt;Spring Framework&lt;/a&gt; &lt;code&gt;Value&lt;/code&gt; annotation:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;@Value(&quot;${service.host.url}&quot;)
private String hostUrl;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;However, because the &lt;a href=&quot;https://code.google.com/p/snakeyaml/&quot; target=&quot;_blank&quot;&gt;Snakeyaml&lt;/a&gt; library that backs the &lt;code&gt;YamlMapFactoryBean&lt;/code&gt; does a literal translation of the configuration to map, separating keys wherever it finds a &apos;.&apos; character, the resolver
cannot find the key &lt;code&gt;service.host.url&lt;/code&gt; (it could find &lt;code&gt;service&lt;/code&gt; and &lt;code&gt;host&lt;/code&gt; under &lt;code&gt;service&lt;/code&gt;, etc).  One way to resolve this is to flatten out the map after loading it, but before returning it from the
property source:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;class YamlMapPropertySourceLoader extends YamlPropertySourceLoader {

    @Override
    public PropertySource load(String name, Resource resource, String profile) throws IOException {
        if (ClassUtils.isPresent(Yaml.class.name, null)) {
            final YamlMapFactoryBean bean = new YamlMapFactoryBean();
            YamlMapFactoryBean factory = new YamlMapFactoryBean()
            factory.setDocumentMatchers(new DefaultProfileDocumentMatcher(), new SpringProfileDocumentMatcher(profile))
            factory.setResolutionMethod(ResolutionMethod.OVERRIDE)
            factory.setResources([resource] as Resource[])
            return new MapPropertySource(name, flattenMap(factory.getObject()))
        }
        null
    }

        private Map flattenMap(Map aMap, prefix=null) {
        aMap.inject([:]) { map, entry -&amp;gt;
            if(entry.value instanceof Map) {
                map += flattenMap(entry.value, createKey(prefix, entry.key))
            } else {
                map.&quot;${createKey(prefix, entry.key)}&quot; = entry.value
            }
            map
        }
    }

    private String createKey(prefix, key) {
        (prefix?.length() &amp;gt; 0) ? &quot;${prefix}.${key}&quot; : key
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In this updated version of the &lt;code&gt;YamlMapPropertySourceLoader&lt;/code&gt;, we use some &lt;a href=&quot;http://groovy.codehaus.org/&quot; target=&quot;_blank&quot;&gt;Groovy&lt;/a&gt;-foo to flatten out the map so that the keys will match the strings provided to the &lt;code&gt;Value&lt;/code&gt; annotation.  Now, when this is combined
together and executed, you can run:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;ctx.getEnvironment().getProperty(&apos;service.host.url&apos;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;to resolve a property placeholder value retrieved from a YAML configuration file in your &lt;a href=&quot;http://groovy.codehaus.org/&quot; target=&quot;_blank&quot;&gt;Groovy&lt;/a&gt; script!&lt;/p&gt;
&lt;/div&gt;
            </description>
        </item>
        <item>
            <title>Spring Application Context and Groovy Scripts</title>
            <link>http://jdpgrailsdev.github.io/blog/2014/12/16/spring_context_groovy_script.html</link>
            <pubDate>Tue, 16 Dec 2014 00:00:00 -0800</pubDate>
            <guid isPermaLink="false">2014/12/16/spring_context_groovy_script.html</guid>
            <description>
                    &lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;I like to use &lt;a href=&quot;http://groovy.codehaus.org/&quot; target=&quot;_blank&quot;&gt;Groovy&lt;/a&gt; to write scripts to help me test parts of my application that require a little more set up than a normal unit test should allow
(think a small-scale integration test).  Often, these scripts take the form of client-based code that establishes a connection to a locally running
instance of my application and verifies that certain operations produce the desired and expected results.  Recently, I found myself in a situation where
I wanted to test some &lt;a href=&quot;http://projects.spring.io/spring-framework/&quot; target=&quot;_blank&quot;&gt;Spring Framework&lt;/a&gt;-based code that uses &lt;a href=&quot;http://www.thymeleaf.org/&quot; target=&quot;_blank&quot;&gt;Thymeleaf&lt;/a&gt; to generate HTML.  I didn&amp;#8217;t necessarily want to extact the code into a separate library just
so I could functionally test it outside of my application.  Instead, I decided to take the project&amp;#8217;s JAR file (as the application is a &lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt; application)
and use it as a dependency in my &lt;a href=&quot;http://groovy.codehaus.org/&quot; target=&quot;_blank&quot;&gt;Groovy&lt;/a&gt; script.  This meant that I would need to find a way to set up the &lt;a href=&quot;http://projects.spring.io/spring-framework/&quot; target=&quot;_blank&quot;&gt;Spring Framework&lt;/a&gt; context, so that all of the required
dependency injection would take place.  This turned out to not be that difficult:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;import com.test.ApplicationConfiguration

import org.springframework.context.annotation.AnnotationConfigApplicationContext

...

def activeProfile = &apos;test&apos;

def ctx = new AnnotationConfigApplicationContext()
ctx.getEnvironment().setActiveProfiles(activeProfile)
ctx.register(ApplicationConfiguration)
ctx.refresh()

...

ctx.close()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In the example above, the script creates an instance of the &lt;code&gt;AnnotationConfigApplicationContext&lt;/code&gt; &lt;a href=&quot;http://projects.spring.io/spring-framework/&quot; target=&quot;_blank&quot;&gt;Spring Framework&lt;/a&gt; context, sets the active profile, registers my Java-based configuration
class (from my application&amp;#8217;s JAR) and refreshes the context.  At this point, you can reference any and all beans created by the configuration:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;def bean = ctx.getBean(&apos;myBean&apos;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You can obviously use the other variants of the &lt;code&gt;ApplicationContext&lt;/code&gt; interface to configure your context (e.g. XML, etc).  In a future post, I will discuss how to leverage the &lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt;
YAML support from a &lt;a href=&quot;http://groovy.codehaus.org/&quot; target=&quot;_blank&quot;&gt;Groovy&lt;/a&gt; script so that you can leverage your application&amp;#8217;s configuration files when in your script.&lt;/p&gt;
&lt;/div&gt;
            </description>
        </item>
        <item>
            <title>Use Inline Attachments as Image Sources in HTML Emails with Spring</title>
            <link>http://jdpgrailsdev.github.io/blog/2014/12/09/email_inline_image_attachments.html</link>
            <pubDate>Tue, 9 Dec 2014 00:00:00 -0800</pubDate>
            <guid isPermaLink="false">2014/12/09/email_inline_image_attachments.html</guid>
            <description>
                    &lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;If you are in the need of generating HTML-based e-mails with images, the simple approach is to simply host the image and link to it
in the HTML.  This will work, but will cause the reciepients (in most e-mail clients) to be prompted as to whether or not they should
download and show the image.  If you want to avoid this (and therefore the stigma of a perceived security threat), you can include
the image as an attachment in the e-mail and reference it using the attachment&amp;#8217;s content ID value:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&amp;lt;img src=&quot;cid:imageName.png&quot;&amp;gt;&amp;lt;/img&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;When the e-mail client loads the message, it will now resolve the image from the inlined attachments included in the e-mail.  This all
sounds great, but how do you get the images in the e-mail?  The solution is to combine the
&lt;a href=&quot;http://docs.spring.io/spring/docs/current/spring-framework-reference/html/mail.html&quot; target=&quot;_blank&quot;&gt;Spring JavaMailSender&lt;/a&gt; with the
&lt;a href=&quot;http://docs.spring.io/spring/docs/current/spring-framework-reference/html/resources.html&quot; target=&quot;_blank&quot;&gt;Spring Resource interface&lt;/a&gt; to
load and store the image data in the generated e-mail.  The first step is to load the images as &lt;code&gt;Resource&lt;/code&gt; objects, either from the
file system or classpath (in this example, we will use the classpath):&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;import org.apache.commons.io.IOUtils;

import org.springframework.core.io.ByteArrayResource;
import org.springframework.core.io.InputStreamSource;

...

InputStreamSource imageSource = new ByteArrayResource(IOUtils.toByteArray(getClass().getResourceAsStream(&quot;/images/logo.png&quot;)))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The code snippet above uses the &lt;a href=&quot;http://commons.apache.org/proper/commons-io/&quot; target=&quot;&quot;_blank&apos;&quot;&gt;Apache Commons IO library&lt;/a&gt; to convert
the image bytes (read from the classpath via the &lt;code&gt;getResourceAsStream()&lt;/code&gt; method) into a byte array.  The byte array is then wrapped
by the Spring &lt;code&gt;ByteArrayResource&lt;/code&gt;, which we will use to create the inline attachment (we could also use the &lt;code&gt;ClassPathResource&lt;/code&gt;).  The next
step is to add the image to the MIME message as an attachment:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;import javax.mail.internet.MimeMessage;

import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.JavaMailSenderImpl;
import org.springframework.mail.javamail.MimeMessageHelper;

...

JavaMailSender mailSender = new JavaMailSenderImpl();  // Or use Spring IoC to inject a pre-configured JavaMailSenderImpl
MimeMessage mimeMessage = mailSender.createMimeMessage();
MimeMessageHelper message = new MimeMessageHelper(mimeMessage, true, &quot;UTF-8&quot;);

// Add information to the message, such as subject, recipients, etc

message.addInline(&quot;logo.png&quot;, imageSource);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The &lt;code&gt;addInline()&lt;/code&gt; method of the &lt;code&gt;MimeMessageHelper&lt;/code&gt; reads the byte data from the &lt;code&gt;InputStreamSource&lt;/code&gt; and creates the inline MIME body part to hold the
attachment.  It also sets the content ID to the name provided by the first parameter.  Now, all that&amp;#8217;s left is to reference the image in our HTML body:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;message.setText(&quot;&amp;lt;img src=\&quot;cid:logo.png\&quot;&amp;gt;&amp;lt;/img&amp;gt;&amp;lt;div&amp;gt;My logo&amp;lt;/div&amp;gt;&quot;, true);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Now, when the e-mail is viewed in the reciepient&amp;#8217;s e-mail client, the image will be displayed from the attachments.  Note that this works with most web mail clients, however,
you should only attach images that are referenced by the HTML body, otherwise they may show up as actual attachments in the e-mail client.&lt;/p&gt;
&lt;/div&gt;
            </description>
        </item>
        <item>
            <title>Groovy Meta Method to Print Current Stacktrace</title>
            <link>http://jdpgrailsdev.github.io/blog/2014/12/02/groovy_print_stack_trace.html</link>
            <pubDate>Tue, 2 Dec 2014 00:00:00 -0800</pubDate>
            <guid isPermaLink="false">2014/12/02/groovy_print_stack_trace.html</guid>
            <description>
                    &lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;If you find yourself in a situation where you cannot debug your application (from an IDE or via attaching remotely to the executing JVM), you can use a little &lt;a href=&quot;http://groovy.codehaus.org/&quot; target=&quot;_blank&quot;&gt;Groovy&lt;/a&gt; meta class
magic to add a method to each class in order to print the current stack of any given line:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;this.class.classLoader.class.classes.each {
    it.metaClass.printStackTrace = { -&amp;gt;
        Thread.currentThread().stackTrace.each { element -&amp;gt;
            println &quot;\tat ${element.className}.${element.methodName}(${element.fileName}:${element.lineNumber})&quot;
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Once the above code has been executed (preferably from your main class), you can use it anywhere in your &lt;a href=&quot;http://groovy.codehaus.org/&quot; target=&quot;_blank&quot;&gt;Groovy&lt;/a&gt; application to print the current stack trace:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;class MyClass {

    def method() {
        printStackTrace()

        ...
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This is particularly useful when trying to track down which of a number of multiple code points might be invoking a given method.&lt;/p&gt;
&lt;/div&gt;
            </description>
        </item>
        <item>
            <title>Execute Functional Tests in a Docker Container with Gradle (Part 2)</title>
            <link>http://jdpgrailsdev.github.io/blog/2014/11/25/functional_tests_gradle_docker_part_ii.html</link>
            <pubDate>Tue, 25 Nov 2014 00:00:00 -0800</pubDate>
            <guid isPermaLink="false">2014/11/25/functional_tests_gradle_docker_part_ii.html</guid>
            <description>
                    &lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In &lt;a href=&quot;http://jdpgrailsdev.github.io/blog/2014/11/18/functional_tests_gradle_docker_part_i.html&quot; target=&quot;_blank&quot;&gt;part one&lt;/a&gt; of this blog post, I discussed how to
build a functional test using &lt;a href=&quot;https://code.google.com/p/spock/&quot; target=&quot;_blank&quot;&gt;Spock&lt;/a&gt; and &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt;.  Normally, this is all that you would need to be able to test the part of your application that relies
on a data source.  However, what can you do if you find yourself in a situation where you do not have access to dependencies or the repositories that provide
them?  The solution is to bundle your tests along with the dependencies and execute them as an application.  In this post, I will discuss how I accomplished
such a solution using &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; and &lt;a href=&quot;https://www.docker.com/&quot; target=&quot;_blank&quot;&gt;Docker&lt;/a&gt;.  First, let&amp;#8217;s look at the &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; build script:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;apply plugin: &apos;groovy&apos;
apply plugin: &apos;jetty&apos;

ext {
    webSourceDir = &quot;$buildDir/www&quot;
    imageName = &quot;${rootProject.name}-functional-tests&quot;
    springVersion = &apos;4.0.7.RELEASE&apos;
}

sourceSets {
    funcTest {
        groovy {
            srcDir file(&apos;src/functionalTest/groovy&apos;)
        }
    }
}

eclipse {
    classpath {
        downloadSources = true
        defaultOutputDir = file(&quot;$buildDir/classes&quot;)
    }
    project {
        name = &quot;${rootProject.name}-functional-tests&quot;
    }
}

eclipseJdt.enabled = false
cleanEclipseJdt.enabled = false

jettyRun {
    httpPort = System.getenv(&apos;PORT&apos;) ? System.getenv(&apos;PORT&apos;) as int : 8080
    contextPath = &apos;status/check&apos;
    webAppSourceDirectory = file(webSourceDir)
}

dependencies {
    compile project(&apos;:app&apos;)		// include the code that is needed to execute the tests (e.g., any entity classes, etc)

    testCompile &apos;junit:junit:4.11&apos;
    testCompile &apos;cglib:cglib-nodep:3.1&apos;
    testCompile &apos;org.objenesis:objenesis:2.1&apos;
    testCompile &apos;org.spockframework:spock-core:0.7-groovy-2.0&apos;
    testCompile &apos;org.spockframework:spock-spring:0.7-groovy-2.0&apos;
    testCompile &quot;org.springframework:spring-test:${springVersion}&quot;

    funcTestCompile sourceSets.main.output
    funcTestCompile configurations.testCompile
    funcTestRuntime configurations.testRuntime
}

task buildDist(type: Tar, group:&apos;Build&apos;, description: &apos;Builds the Tar distribution of the project.&apos;) {
    archiveName = &quot;${rootProject.name}-functional-tests.tar&quot;
    from(&apos;bin&apos;) {
        into(&apos;bin&apos;)
    }
    from(rootProject.projectDir) {
        exclude(&apos;**/build/**&apos;)
        exclude(&apos;**/*.tar&apos;)
        exclude(&apos;**/.gradle/**&apos;)
    }
}

task funcTest(type: Test, group:&apos;Verification&apos;, description: &apos;Runs the functional tests.&apos;) {
    testClassesDir = sourceSets.funcTest.output.classesDir
    classpath = sourceSets.funcTest.runtimeClasspath
    jvmArgs = [&apos;-Duser.timezone=UTC&apos;]
    environment = [:] // any necessary env vars for the test
}

task resolveDependencies {
    doLast {
        project.rootProject.allprojects.each { subProject -&amp;gt;
            subProject.buildscript.configurations.each { configuration -&amp;gt;
                configuration.resolve()
            }
            subProject.configurations.each { configuration -&amp;gt;
                configuration.resolve()
            }
        }
    }
}

task createWebSourceDir {
    doLast {
        new File(webSourceDir).mkdirs()
    }
}

task collectTestResults(type:Tar, group:&apos;Verification&apos;, dependsOn:[&apos;createWebSourceDir&apos;, &apos;funcTest&apos;], description: &apos;Generates a tarball of the collected test report.&apos;) {
    archiveName = &apos;functional-test-reports.tar&apos;
    destinationDir = file(webSourceDir)
    from(&quot;$buildDir/reports/tests&quot;) {
        into(&apos;reports/tests&apos;)
    }
    from(&quot;$buildDir/test-results&quot;) {
        into(&apos;test-results&apos;)
    }
}

task execute(dependsOn:[&apos;jettyRun&apos;])

/*
 * Ensure that the tests are always executed
 */
project.tasks.collectTestResults.outputs.upToDateWhen { false }
project.tasks.funcTest.outputs.upToDateWhen { false }
project.tasks.resolveDependencies.outputs.upToDateWhen { false }
build.finalizedBy(project.tasks.buildDist)
project.tasks.buildDist.dependsOn([&apos;build&apos;])
project.tasks.jettyRun.dependsOn([&apos;collectTestResults&apos;])&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The script above has three very interesting parts:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A custom &lt;code&gt;test&lt;/code&gt; task that runs all of the functional tests defined by the &lt;code&gt;funcTest&lt;/code&gt; configuration.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The inclusion of the &lt;a href=&quot;http://www.gradle.org/docs/current/userguide/jetty_plugin.html&quot; target=&quot;_blank&quot;&gt;Gradle Jetty Plugin&lt;/a&gt; to expose the test reports.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A custom task (&lt;code&gt;resolveDependencies&lt;/code&gt;) that will ensure that all the required dependencies are resolved and included when building the &lt;a href=&quot;https://www.docker.com/&quot; target=&quot;_blank&quot;&gt;Docker&lt;/a&gt; image.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Now let&amp;#8217;s look at the &lt;code&gt;Dockerfile&lt;/code&gt; for the functional tests before tying it all together.  Below is a simple &lt;code&gt;Dockerfile&lt;/code&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code&gt;FROM registry.hub.docker.com/your-base-image:latest

# Install the functional tests
RUN mkdir /var/tests
ADD build/distributions/my-functional-tests.tar /var/tests
RUN chmod +x /var/tests/bin/functional-tests.sh

# Force Gradle to download all of its dependencies at image build time!
RUN rm -rf /root/.gradle
RUN cd /var/tests &amp;amp;&amp;amp; ./gradlew --refresh-dependencies resolveDependencies &amp;gt; /dev/null

EXPOSE 8080
CMD [&quot;cd /var/tests &amp;amp;&amp;amp; ./gradlew --offline clean execute&quot;]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The &lt;code&gt;Dockerfile&lt;/code&gt; extracts the contents of the TAR into the &lt;code&gt;/var/tests&lt;/code&gt; folder inside the &lt;a href=&quot;https://www.docker.com/&quot; target=&quot;_blank&quot;&gt;Docker&lt;/a&gt; image.  Once extracted, the &lt;code&gt;Dockerfile&lt;/code&gt; also invokes the &lt;code&gt;resolveDepednencies&lt;/code&gt; custom task
that we saw in the &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; build script above.  Because the &lt;a href=&quot;https://www.docker.com/&quot; target=&quot;_blank&quot;&gt;Docker&lt;/a&gt; image is being built on a machine that has access to our dependency repositories, it can resolve
everything needed at image creation time.  By resolving the dependencies at this point, we guarantee that the dependencies have been downloaded and cached by &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; inside of the
&lt;a href=&quot;https://www.docker.com/&quot; target=&quot;_blank&quot;&gt;Docker&lt;/a&gt; image.  The final piece of the puzzle is the &lt;code&gt;CMD&lt;/code&gt; directive, which runs the custom &lt;code&gt;execute&lt;/code&gt; task from the &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; build script.  As we saw above, the &lt;code&gt;execute&lt;/code&gt; task launches Jetty, which in turn
launches the functional tests via the &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; task dependency set up in the script.  Upon successful completion of the tests, the test reports generated by &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; are exposed by Jetty so that they can be
viewed/copied/etc.  By tying all of these pieces together, we have created a stand-alone &lt;a href=&quot;https://www.docker.com/&quot; target=&quot;_blank&quot;&gt;Docker&lt;/a&gt; image capable of executing functional tests
using &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; in an environment that does not have the ability to resolve dependencies!&lt;/p&gt;
&lt;/div&gt;
            </description>
        </item>
    </channel>
</rss>
