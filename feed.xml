<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>The Flowers Are Still Standing</title>
        <link>http://jdpgrailsdev.github.io/blog/</link>
        <atom:link href="http://jdpgrailsdev.github.io/blog//feed.xml" rel="self" type="application/rss+xml" />
        <description>Jonathan Pearlin's Blog</description>
        <language>en-us</language>
        <pubDate>Wed, 19 Aug 2015 07:42:44 -0700</pubDate>
        <lastBuildDate>Wed, 19 Aug 2015 07:42:44 -0700</lastBuildDate>
        <image>
            <url>http://jdpgrailsdev.github.io/blog//img/robot_devil.png</url>
            <title>Jonathan Pearlin's Blog</title>
            <link>http://jdpgrailsdev.github.io/blog/</link>
        </image>
        <item>
            <title>Using Spock/CGLIB with Java 8 and Gradle</title>
            <link>http://jdpgrailsdev.github.io/blog/2015/08/18/java_8_spock_cglib_gradle.html</link>
            <pubDate>Tue, 18 Aug 2015 00:00:00 -0700</pubDate>
            <guid isPermaLink="false">2015/08/18/java_8_spock_cglib_gradle.html</guid>
            <description>
                    &lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Recently, I attempted to convert a project that uses &lt;a href=&quot;https://github.com/cglib/cglib&quot; target=&quot;_blank&quot;&gt;CGLIB&lt;/a&gt; and &lt;a href=&quot;https://github.com/spockframework/spock&quot; target=&quot;_blank&quot;&gt;Spock Framework&lt;/a&gt; to execute unit tests to use Java 8 source
and target versions.  When I went to run the unit tests, I was met with a nasty &lt;code&gt;java.lang.IllegalArgumentException&lt;/code&gt;.  Some
quick internet searching showed that there is an existing issue with the currently released version of &lt;a href=&quot;https://github.com/cglib/cglib&quot; target=&quot;_blank&quot;&gt;CGLIB&lt;/a&gt; and the
version of the &lt;a href=&quot;https://github.com/llbit/ow2-asm&quot; target=&quot;_blank&quot;&gt;ASM&lt;/a&gt; library it depends on.  Despite  &lt;a href=&quot;https://github.com/cglib/cglib/issues/8&quot; target=&quot;_blank&quot;&gt;pleas&lt;/a&gt;
from the community, an updated version of &lt;a href=&quot;https://github.com/cglib/cglib&quot; target=&quot;_blank&quot;&gt;CGLIB&lt;/a&gt; with Java 8 compatibility has not yet been released.  However, there are commits on the project&amp;#8217;s trunk
that add Java 8 compatibility.  Luckily, a quick look at the &lt;a href=&quot;https://github.com/spockframework/spock&quot; target=&quot;_blank&quot;&gt;Spock Framework&lt;/a&gt; source code showed me how to get around this issue.  The trick is to use &lt;a href=&quot;https://jitpack.io&quot; target=&quot;_blank&quot;&gt;JitPack.io&lt;/a&gt; as a Maven
repository in your build script to build a particular commit hash of the project and expose it as a dependency for your project.  After some digging through the
source, I determined that &lt;a href=&quot;https://github.com/cglib/cglib/commits/master&quot; target=&quot;_blank&quot;&gt;commit 52e118aca4&lt;/a&gt; is the proper one to use.
To use this version of &lt;a href=&quot;https://github.com/cglib/cglib&quot; target=&quot;_blank&quot;&gt;CGLIB&lt;/a&gt; in your &lt;code&gt;build.gradle&lt;/code&gt; file, you simply need to add the following:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;repositories {
    // ...
    maven { url &quot;https://jitpack.io&quot; }
}

dependencies {
    testCompile &apos;com.github.cglib:cglib:52e118aca4&apos;
    testCompile &apos;org.spockframework:spock-core:0.7-groovy-2.0&apos;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You can generate this information using &lt;a href=&quot;https://jitpack.io&quot; target=&quot;_blank&quot;&gt;JitPack.io&lt;/a&gt; itself by going to the following URL:  &lt;a href=&quot;https://jitpack.io/#cglib/cglib/52e118aca4&quot; class=&quot;bare&quot;&gt;https://jitpack.io/#cglib/cglib/52e118aca4&lt;/a&gt;.  Now, my project will get &lt;a href=&quot;https://jitpack.io&quot; target=&quot;_blank&quot;&gt;JitPack.io&lt;/a&gt;
to build the custom release of &lt;a href=&quot;https://github.com/cglib/cglib&quot; target=&quot;_blank&quot;&gt;CGLIB&lt;/a&gt; without me needing to build and push it into a repository!&lt;/p&gt;
&lt;/div&gt;
            </description>
        </item>
        <item>
            <title>Upload File from Classpath/In-Memory Using Spring RestTemplate</title>
            <link>http://jdpgrailsdev.github.io/blog/2015/04/21/spring_file_upload.html</link>
            <pubDate>Tue, 21 Apr 2015 00:00:00 -0700</pubDate>
            <guid isPermaLink="false">2015/04/21/spring_file_upload.html</guid>
            <description>
                    &lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;File uploads via an HTTP POST to an end point are pretty easy using the &lt;code&gt;RestTemplate&lt;/code&gt; and &lt;code&gt;FileResource&lt;/code&gt; classes of the &lt;a href=&quot;http://projects.spring.io/spring-framework/&quot; target=&quot;_blank&quot;&gt;Spring Framework&lt;/a&gt;.  However,
this approach assumes that the file to be uploaded resides on disk.  What happens if you want to dynamically create the uploaded file in
memory or want to use a file on the classpath?  The answer is to create a slight tweak to the &lt;code&gt;ByteArrayResource&lt;/code&gt; implementation so that
the proper from data header attributes are set in the POST body.  To do this, first extend the &lt;code&gt;ByteArrayResource&lt;/code&gt; so that you can set
the &lt;code&gt;filename&lt;/code&gt; of the resource:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class FileMessageResource extends ByteArrayResource {

    /**
     * The filename to be associated with the {@link MimeMessage} in the form data.
     */
    private final String filename;

    /**
     * Constructs a new {@link MimeMessageRe
     * @param byteArray A byte array containing data from a {@link MimeMessage}.
     * @param filename The filename to be associated with the {@link MimeMessage} in
     * 	the form data.
     */
    public MimeMessageResource(final byte[] byteArray, final String filename) {
        super(byteArray);
        this.filename = filename;
    }

    @Override
    public String getFilename() {
        return filename;
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Next, create your new resource and add it to the POST body.  From there, simply pass the POST body to the
&lt;code&gt;RestTemplate&lt;/code&gt; to send the file to the end point:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;final MultiValueMap&amp;lt;String,Object&amp;gt; data = new LinkedMultiValueMap&amp;lt;String,Object&amp;gt;();
data.add(&quot;file&quot;, new FileMessageResource(fileBytes, &quot;upload.txt&quot;));
final HttpEntity&amp;lt;MultiValueMap&amp;lt;String, Object&amp;gt;&amp;gt; requestEntity = new HttpEntity&amp;lt;MultiValueMap&amp;lt;String, Object&amp;gt;&amp;gt;(data);
final ResponseEntity&amp;lt;Map&amp;lt;String,String&amp;gt;&amp;gt; response = getRestTemplate().exchange(url, HttpMethod.POST, requestEntity, new ParameterizedTypeReference&amp;lt;Map&amp;lt;String,String&amp;gt;&amp;gt;() {});&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The result is a form POST to the end point with the proper section header:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code&gt;Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;upload.txt&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
            </description>
        </item>
        <item>
            <title>Load Testing with GPars and Google Guava</title>
            <link>http://jdpgrailsdev.github.io/blog/2015/04/07/gpars_guava_load_test.html</link>
            <pubDate>Tue, 7 Apr 2015 00:00:00 -0700</pubDate>
            <guid isPermaLink="false">2015/04/07/gpars_guava_load_test.html</guid>
            <description>
                    &lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;I set out a few days back to write a simple &lt;a href=&quot;http://groovy-lang.org/&quot; target=&quot;_blank&quot;&gt;Groovy&lt;/a&gt; script that would accomplish the following:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Send data to a &lt;a href=&quot;http://kafka.apache.org/&quot; target=&quot;_blank&quot;&gt;Kafka&lt;/a&gt; topic from X concurrent producers.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Run for a set duration&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Achieve a set number of sends per minute&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;To do so, I decided to use &lt;a href=&quot;http://www.gpars.org/guide/index.html&quot; target=&quot;_blank&quot;&gt;GPars Framework&lt;/a&gt;, which is a &quot;concurrency and parallelism library for Java and Groovy
that gives you a number of high-level abstractions for writing concurrent and parallel code in Groovy.&quot;  Additionally,
I decided to make use of the &lt;a href=&quot;https://github.com/google/guava&quot; target=&quot;_blank&quot;&gt;Google Guava&lt;/a&gt; &lt;a href=&quot;http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/util/concurrent/RateLimiter.html&quot; target=&quot;_blank&quot;&gt;RateLimiter&lt;/a&gt;
class to control how much data is produced.  The resulting script is pretty simple:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;@Grapes([
    @Grab(group=&apos;org.codehaus.gpars&apos;, module=&apos;gpars&apos;, version=&apos;1.2.1&apos;),
    @Grab(group=&apos;com.google.guava&apos;, module=&apos;guava&apos;, version=&apos;18.0&apos;),
    @GrabExclude(&apos;commons-logging:commons-logging&apos;)])

def cli = new CliBuilder(usage:&apos;groovy loadTest.groovy &apos;)
cli.p(longOpt:&apos;parallelism&apos;, args: 1, argName: &apos;parallelism&apos;, &apos;The number of producers to execute in parallel.  Defaults to 10.&apos;)
cli.d(longOpt:&apos;duration&apos;, args: 1, argName: &apos;duration&apos;, &apos;The duration of the test in minutes.  Defaults to 1 minute.&apos;)
cli.r(longOpt:&apos;target-rate&apos;, args: 1, argName: &apos;targetRate&apos;, &apos;The target aggregate rate of messages to be produced per minute.  Defaults to 60.&apos;)
cli.h(longOpt:&apos;help&apos;, &apos;Displays the usage information for this script.&apos;)

def run = { -&amp;gt;
    // Do the actual work here (e.g. publish a message, etc)
}

def setup = { -&amp;gt;
    // Do any pre-test setup here (e.g. retrieving data, configuration, etc)
}

def options = cli.parse(args)

if(options?.h) {
    cli.usage()
} else {
   def duration = options?.d ? TimeUnit.MINUTES.toMillis(options.d as long) :  TimeUnit.MINUTES.toMillis(1l)
   def parallelism = options?.p ?: 10
   def targetRate = options?.r ?: 60.0

   println &apos;***********************************************&apos;
   println &apos;Load Test&apos;
   println &quot;Test will run for ${TimeUnit.MILLISECONDS.toMinutes(duration)} minute(s) using ${parallelism} producers with a target rate of ${targetRate} messages per minute.&quot;

   setup()

   println &apos;Starting the test....&apos;

   def rateLimiter = RateLimiter.create((targetRate as double)/TimeUnit.MINUTES.toSeconds(1))
   def startTime = System.currentTimeMillis()
   def total = 0
   while((System.currentTimeMillis() - startTime) &amp;lt; duration) {
       GParsExecutorsPool.withPool(parallelism as int) { ExecutorService service -&amp;gt;
           (parallelism as int).times {
               rateLimiter.acquire()
               service.submit({ run() } as Runnable)
           }
           total += parallelism as int
       }
       println &quot;Test iteration complete.  Total sent so far: ${total}, ${TimeUnit.MILLISECONDS.toSeconds(duration - (System.currentTimeMillis() - startTime))} second(s) remaining.&quot;
   }
   println &apos;Test complete.&apos;
   System.exit(0)
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The key points in the script above is the use of the &lt;code&gt;GParsExecutorsPool&lt;/code&gt; to handle the creation of a configured thread pool and the inclusion of
the &lt;code&gt;RateLimiter&lt;/code&gt; to slow down the execution loop to meet the target rate.  Finally, all of this is done in a &lt;code&gt;while&lt;/code&gt; loop that keeps looping until
the requested duration has been achieved.  The end result is a simple script that allows you to generate concurrent request load at a target rate for
a set duration.&lt;/p&gt;
&lt;/div&gt;
            </description>
        </item>
        <item>
            <title>Configure Jetty to Listen on Multiple Ports in a Spring Boot Application</title>
            <link>http://jdpgrailsdev.github.io/blog/2015/03/10/spring_boot_jetty_multi_port.html</link>
            <pubDate>Tue, 10 Mar 2015 00:00:00 -0700</pubDate>
            <guid isPermaLink="false">2015/03/10/spring_boot_jetty_multi_port.html</guid>
            <description>
                    &lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The &lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt; &lt;a href=&quot;http://docs.spring.io/spring-boot/docs/current/reference/html/howto-embedded-servlet-containers.html#howto-configure-jetty&quot; target=&quot;_blank&quot;&gt;documentation&lt;/a&gt; and
&lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples/spring-boot-sample-jetty&quot; target=&quot;_blank&quot;&gt;sample applications&lt;/a&gt; contain good information and examples
of how to use &lt;a href=&quot;http://eclipse.org/jetty/&quot; target=&quot;_blank&quot;&gt;Jetty&lt;/a&gt; in a &lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt; application instead of the default embedded Apache Tomcat server.  However, the documentation and examples do not really address how to
customize &lt;a href=&quot;http://eclipse.org/jetty/&quot; target=&quot;_blank&quot;&gt;Jetty&lt;/a&gt; as in depth as the Tomcat examples.  Recently, I found the need to make a &lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt; application using &lt;a href=&quot;http://eclipse.org/jetty/&quot; target=&quot;_blank&quot;&gt;Jetty&lt;/a&gt; listen on multiple ports for incoming HTTP traffic.
While this is not necessarily a normal use case, it does come up often, especially when the need to listen for both HTTP and HTTPS traffic is a requirement.  In a
&lt;a href=&quot;http://jdpgrailsdev.github.io/blog/2014/10/07/spring_boot_jetty_thread_pool.html&quot; target=&quot;_blank&quot;&gt;previous post&lt;/a&gt;, I showed how to customize the embedded &lt;a href=&quot;http://eclipse.org/jetty/&quot; target=&quot;_blank&quot;&gt;Jetty&lt;/a&gt; server in order to
change the size of the thread pool used for incoming connections.  Just like the approach outlined in that post, the way to configure the embedded &lt;a href=&quot;http://eclipse.org/jetty/&quot; target=&quot;_blank&quot;&gt;Jetty&lt;/a&gt; server in your &lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt;
application to listen to multiple ports is very similar:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;@Bean
public JettyEmbeddedServletContainerFactory jettyEmbeddedServletContainerFactory(
        @Value(&quot;${server.port:8080}&quot;) final String mainPort,
        @Value(&quot;#{&apos;${server.secondary.ports}&apos;.split(&apos;,&apos;)}&quot;) final List&amp;lt;String&amp;gt; secondaryPorts) {

    final JettyEmbeddedServletContainerFactory factory =  new JettyEmbeddedServletContainerFactory(Integer.valueOf(mainPort));

    // Add customized Jetty configuration with non blocking connection handler
    factory.addServerCustomizers(new JettyServerCustomizer() {
        @Override
        public void customize(final Server server) {
            // Register an additional connector for each secondary port.
            for(final String secondaryPort : secondaryPorts) {
                final NetworkTrafficServerConnector connector = new NetworkTrafficServerConnector(server);
                connector.setPort(Integer.valueOf(secondaryPort));
                server.addConnector(connector);
            }

            // Additional configuration
        }
    });
    return factory;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The example above uses the &lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt; provided &lt;code&gt;JettyServerCustomizer&lt;/code&gt; to register additional &lt;code&gt;NetworkTrafficServerConnector&lt;/code&gt; instances for each
secondary port provided in the application&amp;#8217;s configuration.  Additionally, the &lt;code&gt;server.port&lt;/code&gt; &lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt; property is still used for the
main application port and is passed to the &lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt; &lt;code&gt;JettyEmbeddedServletContainerFactory&lt;/code&gt;, just as it would be if you simply included
the appropriate starter library and set the property, per the documentation.  Finally, the application configuration contains the following configuration
to make it all work:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;server:
  port: &quot;8000&quot;
  secondary:
    ports: &quot;8082,8083,8084&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;When the application starts up, you can confirm that it is indeed listening on the multiple ports by looking for the following in the output:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code&gt;2015-03-09 15:13:35.483  INFO 1416 --- [           main] o.eclipse.jetty.server.ServerConnector   : Started ServerConnector@121ee28d{HTTP/1.1}{0.0.0.0:8080}
2015-03-09 15:13:35.483  INFO 1416 --- [           main] o.e.j.s.NetworkTrafficServerConnector    : Started NetworkTrafficServerConnector@36d64b9{HTTP/1.1}{0.0.0.0:8082}
2015-03-09 15:13:35.487  INFO 1416 --- [           main] o.e.j.s.NetworkTrafficServerConnector    : Started NetworkTrafficServerConnector@e51235{HTTP/1.1}{0.0.0.0:8083}
2015-03-09 15:13:35.488  INFO 1416 --- [           main] o.e.j.s.NetworkTrafficServerConnector    : Started NetworkTrafficServerConnector@3f0e5608{HTTP/1.1}{0.0.0.0:8084}
2015-03-09 15:13:35.489  INFO 1416 --- [           main] .s.b.c.e.j.JettyEmbeddedServletContainer : Jetty started on port(s) 8080 (http/1.1), 8082 (http/1.1), 8083 (http/1.1), 8084 (http/1.1)
2015-03-09 15:13:35.491  INFO 1416 --- [           main] com.test.Application                     : Started Application in 5.346 seconds (JVM running for 12.321)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
            </description>
        </item>
        <item>
            <title>Using Thrift Generated Classes with a JSON REST API in Spring Boot - Part II</title>
            <link>http://jdpgrailsdev.github.io/blog/2015/03/03/thrift_json_rest_spring_boot_ii.html</link>
            <pubDate>Tue, 3 Mar 2015 00:00:00 -0800</pubDate>
            <guid isPermaLink="false">2015/03/03/thrift_json_rest_spring_boot_ii.html</guid>
            <description>
                    &lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In my &lt;a href=&quot;http://jonathanpearlin.com/blog/2015/02/24/thrift_json_rest_spring_boot_part_i.html&quot; target=&quot;_blank&quot;&gt;previous post&lt;/a&gt;, I discussed how
to create a custom &lt;a href=&quot;https://github.com/FasterXML/jackson&quot; target=&quot;_blank&quot;&gt;Jackson 2&lt;/a&gt; serializer to handle the conversion of JSON into &lt;a href=&quot;https://thrift.apache.org/&quot; target=&quot;_blank&quot;&gt;Apache Thrift&lt;/a&gt; objects within a &lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt; application that uses
&lt;a href=&quot;https://spring.io/guides/gs/rest-service/&quot; target=&quot;_blank&quot;&gt;Spring&amp;#8217;s REST support&lt;/a&gt;.  In this post, I am going to tackle the other side of the coin:  de-serialization, or converting an &lt;a href=&quot;https://thrift.apache.org/&quot; target=&quot;_blank&quot;&gt;Apache Thrift&lt;/a&gt; object from JSON.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_custom_de_serializer&quot;&gt;Custom De-serializer&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Much like the previous example, we need to create a custom &lt;a href=&quot;https://github.com/FasterXML/jackson&quot; target=&quot;_blank&quot;&gt;Jackson 2&lt;/a&gt; de-serializer to handle the conversion of &lt;a href=&quot;https://thrift.apache.org/&quot; target=&quot;_blank&quot;&gt;Apache Thrift&lt;/a&gt;-based objects from JSON:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;package com.example.json;

import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.ParameterizedType;
import java.util.Iterator;
import java.util.Map;

import org.apache.thrift.TBase;
import org.apache.thrift.TException;
import org.apache.thrift.TFieldIdEnum;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.JsonDeserializer;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.JsonNodeType;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.fasterxml.jackson.databind.type.TypeFactory;
import com.google.common.base.CaseFormat;

/**
 * This abstract class represents a generic de-serializer for converting JSON to Thrift-based entities.
 *
 * @param &amp;lt;E&amp;gt; An implementation of the {@link TFieldIdEnum} interface.
 * @param &amp;lt;T&amp;gt; An implementation of the {@link TBase} interface.
 */
public abstract class AbstractThriftDeserializer&amp;lt;E extends TFieldIdEnum, T extends TBase&amp;lt;T, E&amp;gt;&amp;gt; extends JsonDeserializer&amp;lt;T&amp;gt; {

    private static Logger log = LoggerFactory.getLogger(AbstractThriftDeserializer.class);

    @Override
    public T deserialize(final JsonParser jp, final DeserializationContext ctxt) throws IOException, JsonProcessingException {
        final T instance = newInstance();
        final ObjectMapper mapper = (ObjectMapper)jp.getCodec();
        final ObjectNode rootNode = (ObjectNode)mapper.readTree(jp);
        final Iterator&amp;lt;Map.Entry&amp;lt;String, JsonNode&amp;gt;&amp;gt; iterator = rootNode.fields();

        while(iterator.hasNext()) {
            final Map.Entry&amp;lt;String, JsonNode&amp;gt; currentField = iterator.next();
            try {
                /*
                 * If the current node is not a null value, process it.  Otherwise,
                 * skip it.  Jackson will treat the null as a 0 for primitive
                 * number types, which in turn will make Thrift think the field
                 * has been set.
                 */
                if(currentField.getValue().getNodeType() != JsonNodeType.NULL) {
                    final E field = getField(CaseFormat.LOWER_UNDERSCORE.to(CaseFormat.UPPER_UNDERSCORE, currentField.getKey()));
                    final JsonParser parser = currentField.getValue().traverse();
                    parser.setCodec(mapper);
                    final Object value = mapper.readValue(parser, generateValueType(instance, field));
                    if(value != null) {
                        log.debug(&quot;Field {} produced value {} of type {}.&quot;, currentField.getKey(), value, value.getClass().getName());
                        instance.setFieldValue(field, value);
                    } else {
                        log.debug(&quot;Field {} contains a null value.  Skipping...&quot;, currentField.getKey());
                    }
                } else {
                    log.debug(&quot;Field {} contains a null value.  Skipping...&quot;, currentField.getKey());
                }
            } catch (final NoSuchFieldException | IllegalArgumentException e) {
                log.error(&quot;Unable to de-serialize field &apos;{}&apos;.&quot;, currentField.getKey(), e);
                ctxt.mappingException(e.getMessage());
            }
        }

        try {
            // Validate that the instance contains all required fields.
            validate(instance);
        } catch (final TException e) {
            log.error(&quot;Unable to deserialize JSON &apos;{}&apos; to type &apos;{}&apos;.&quot;, jp.getValueAsString(), instance.getClass().getName(), e);
            NewRelic.noticeError(e);
            ctxt.mappingException(e.getMessage());
        }

        return instance;
    }

    /**
     * Returns the {@code &amp;lt;E&amp;gt;} enumerated value that represents the target
     * field in the Thrift entity referenced in the JSON document.
     * @param fieldName The name of the Thrift entity target field.
     * @return The {@code &amp;lt;E&amp;gt;} enumerated value that represents the target
     *   field in the Thrift entity referenced in the JSON document.
     */
    protected abstract E getField(String fieldName);

    /**
     * Creates a new instance of the Thrift entity class represented by this deserializer.
     * @return A new instance of the Thrift entity class represented by this deserializer.
     */
    protected abstract T newInstance();

    /**
     * Validates that the Thrift entity instance contains all required fields after deserialization.
     * @param instance A Thrift entity instance.
     * @throws TException if unable to validate the instance.
     */
    protected abstract void validate(T instance) throws TException;

    /**
     * Generates a {@link JavaType} that matches the target Thrift field represented by the provided
     * {@code &amp;lt;E&amp;gt;} enumerated value.  If the field&apos;s type includes generics, the generics will
     * be added to the generated {@link JavaType} to support proper conversion.
     * @param thriftInstance The Thrift-generated class instance that will be converted to/from JSON.
     * @param field A {@code &amp;lt;E&amp;gt;} enumerated value that represents a field in a Thrift-based entity.
     * @return The {@link JavaType} representation of the type associated with the field.
     * @throws NoSuchFieldException if unable to determine the field&apos;s type.
     * @throws SecurityException if unable to determine the field&apos;s type.
     */
    protected JavaType generateValueType(final T thriftInstance, final E field) throws NoSuchFieldException, SecurityException {
        final TypeFactory typeFactory = TypeFactory.defaultInstance();

        final Field declaredField = thriftInstance.getClass().getDeclaredField(field.getFieldName());
        if(declaredField.getType().equals(declaredField.getGenericType())) {
            log.debug(&quot;Generating JavaType for type &apos;{}&apos;.&quot;, declaredField.getType());
            return typeFactory.constructType(declaredField.getType());
        } else {
            final ParameterizedType type = (ParameterizedType)declaredField.getGenericType();
            final Class&amp;lt;?&amp;gt;[] parameterizedTypes = new Class&amp;lt;?&amp;gt;[type.getActualTypeArguments().length];
            for(int i=0; i&amp;lt;type.getActualTypeArguments().length; i++) {
                parameterizedTypes[i] = (Class&amp;lt;?&amp;gt;)type.getActualTypeArguments()[i];
            }
            log.debug(&quot;Generating JavaType for type &apos;{}&apos; with generics &apos;{}&apos;&quot;, declaredField.getType(), parameterizedTypes);
            return typeFactory.constructParametricType(declaredField.getType(), parameterizedTypes);
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This approach uses the &lt;code&gt;TFieldIdEnum&lt;/code&gt; enumeration present in each &lt;a href=&quot;https://thrift.apache.org/&quot; target=&quot;_blank&quot;&gt;Apache Thrift&lt;/a&gt; object that defines the available fields in the object
to determine the mapping of the current JSON field into the &lt;a href=&quot;https://thrift.apache.org/&quot; target=&quot;_blank&quot;&gt;Apache Thrift&lt;/a&gt; object.  In order to ensure proper type coercion, an additional
method (&lt;code&gt;generateValueType&lt;/code&gt;) is provided to handle cases where &lt;a href=&quot;https://github.com/FasterXML/jackson&quot; target=&quot;_blank&quot;&gt;Jackson 2&lt;/a&gt; needs to be instructed about possible generic types.  Finally,
the generated &lt;a href=&quot;https://thrift.apache.org/&quot; target=&quot;_blank&quot;&gt;Apache Thrift&lt;/a&gt; object is validated to ensure all required fields are present in the JSON.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In order to make this solution re-usable, three &lt;code&gt;abstract&lt;/code&gt; methods are provided so that this common logic for de-serialization can be re-used
by more than one &lt;a href=&quot;https://thrift.apache.org/&quot; target=&quot;_blank&quot;&gt;Apache Thrift&lt;/a&gt; object:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;package com.example.json;

import org.apache.thrift.TException;

import com.example.v2.Book;

public class BookDeserializer extends AbstractThriftDeserializer&amp;lt;Book._Fields, Book&amp;gt; {

    @Override
    protected Book._Fields getField(final String fieldName) {
        return Book._Fields.valueOf(fieldName);
    }

    @Override
    protected Book newInstance() {
        return new Book();
    }

    @Override
    protected void validate(final Book instance) throws TException{
        instance.validate();
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The final step is to register our custom de-serializer with {spring} in our controller, just like we did for the custom serializer:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;import org.springframework.beans.factory.InitializingBean;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.example.v1.Book;
import com.example.json.BookDeserializer;
import com.example.json.BookSerializer;
import com.fasterxml.jackson.core.Version;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;

@RestController
@RequestMapping(&quot;/api/v1/books&quot;)
public class BookController implements InitializingBean {

    @Autowired
    private BookRepository bookRepository;

    @Autowired
    private MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter;

    @Override
    public void afterPropertiesSet() throws Exception {
        // Register the custom Thrift &amp;lt;&amp;gt; JSON deserializers/serializers.
        final ObjectMapper mapper = mappingJackson2HttpMessageConverter.getObjectMapper();
        final SimpleModule bookModule = new SimpleModule(&quot;Book&quot;, new Version(1,0,0,null,null,null));
        bookModule.addSerializer(new BookSerializer());
        bookModule.addDeserializer(new BookDeserializer());
        mapper.registerModule(bookModule);
    }

    ....

    @RequestMapping(method=RequestMethod.POST, produces = {MediaType.APPLICATION_JSON_VALUE}, consumes = {MediaType.ALL_VALUE})
    public ResponseEntity&amp;lt;Book&amp;gt; createBook(@RequestParam(@RequestBody final Book book) {
        if(book != null) {
            // Save the book!
        } else {
            return new ResponseEntity&amp;lt;Book&amp;gt;(HttpStatus.BAD_REQUEST);
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Now, whenever a JSON payload is provided to the &lt;code&gt;createBook&lt;/code&gt; method via an HTTP POST, &lt;a href=&quot;https://github.com/FasterXML/jackson&quot; target=&quot;_blank&quot;&gt;Jackson 2&lt;/a&gt; will handle the conversion of the JSON
into our &lt;a href=&quot;https://thrift.apache.org/&quot; target=&quot;_blank&quot;&gt;Apache Thrift&lt;/a&gt; &lt;code&gt;Book&lt;/code&gt; object!  By combining both the serialization and de-serialization code, you can now re-use your &lt;a href=&quot;https://thrift.apache.org/&quot; target=&quot;_blank&quot;&gt;Apache Thrift&lt;/a&gt; model
as your DTO&amp;#8217;s for an additional RESTful interface.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
            </description>
        </item>
    </channel>
</rss>
