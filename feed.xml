<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Why We Can't Have Nice Things</title>
        <link>http://jdpgrailsdev.github.io/blog/</link>
        <atom:link href="http://jdpgrailsdev.github.io/blog//feed.xml" rel="self" type="application/rss+xml" />
        <description>Jonathan Pearlin's Blog</description>
        <language>en-us</language>
        <pubDate>Tue, 25 Feb 2014 12:56:41 -0500</pubDate>
        <lastBuildDate>Tue, 25 Feb 2014 12:56:41 -0500</lastBuildDate>
        <image>
            <url>http://jdpgrailsdev.github.io/blog//img/robot_devil.png</url>
            <title>Jonathan Pearlin's Blog</title>
            <link>http://jdpgrailsdev.github.io/blog/</link>
        </image>
        <item>
            <title>Programmatically building CKEditor source in Grails</title>
            <link>http://jdpgrailsdev.github.io/blog//2014/02/25/grails_gant_ckeditor.html</link>
            <pubDate>Tue, 25 Feb 2014 00:00:00 -0500</pubDate>
            <guid isPermaLink="false">/2014/02/25/grails_gant_ckeditor.html</guid>
            <description>
                    &lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The &lt;a href=&quot;http://grails.org&quot;&gt;Grails&lt;/a&gt; Framework has some interesting quirks, particular when it comes to dependency management and build/deploy.  With a &lt;a href=&quot;http://grails.org&quot;&gt;Grails&lt;/a&gt; plugin, you can define dependencies in its &lt;code&gt;BuildConfig.groovy&lt;/code&gt; source file or you can place Java JAR files in the &lt;code&gt;lib&lt;/code&gt;
directory of the plugin.  Either will get included in the packaged plugin (and by extension, the packaged WAR of the application that includes the plugin) unless other special steps are taken to preclude them at package time.  This became an issue for me
recently when using the builder provided by &lt;a href=&quot;http://ckeditor.com/&quot;&gt;CKEditor&lt;/a&gt; within a &lt;a href=&quot;http://grails.org&quot;&gt;Grails&lt;/a&gt; plugin to compile from source the &lt;a href=&quot;http://ckeditor.com/&quot;&gt;CKEditor&lt;/a&gt; JavaScript files.  We had originally put the &lt;a href=&quot;http://ckeditor.com/&quot;&gt;CKEditor&lt;/a&gt; builder JAR in the &lt;code&gt;lib&lt;/code&gt; folder of a plugin, as the &lt;a href=&quot;http://ckeditor.com/&quot;&gt;CKEditor&lt;/a&gt; project does not
publish its artifacts to &lt;a href=&quot;http://maven.apache.org/&quot;&gt;Maven&lt;/a&gt;.  This worked fine until we happened to update the version of &lt;a href=&quot;http://code.google.com/p/guava-libraries/&quot;&gt;Guava&lt;/a&gt; that the plugin depended on.  The net result of this was a fun game of classpath roulette, as the builder JAR provided by &lt;a href=&quot;http://ckeditor.com/&quot;&gt;CKEditor&lt;/a&gt; includes copies of
an older version of &lt;a href=&quot;http://code.google.com/p/guava-libraries/&quot;&gt;Guava&lt;/a&gt; inside its JAR (don&amp;#8217;t get me started on this).  I was able to determine this by using JBoss&amp;#8217;s &lt;a href=&quot;http://www.jboss.org/tattletale&quot;&gt;http://www.jboss.org/tattletale&lt;/a&gt; library to check for duplicate classes on the classpath (In a future post, I will talk about how I added
JBoss&amp;#8217;s &lt;a href=&quot;http://www.jboss.org/tattletale&quot;&gt;tattletale&lt;/a&gt; to our &lt;a href=&quot;http://grails.org&quot;&gt;Grails&lt;/a&gt; builds to check for duplicate classes on the classpath, though it less important in &lt;a href=&quot;http://grails.org&quot;&gt;Grails&lt;/a&gt; 2.3+, where you can use &lt;a href=&quot;http://maven.apache.org/&quot;&gt;Maven&lt;/a&gt; POM files and the enforcer plugin to do the same thing).  Because
we had the JAR in the &lt;code&gt;lib&lt;/code&gt; directory, it gets included on the classpath and packaged in the WAR, but does not get conflict resolved with any dependencies included in the &lt;code&gt;BuildConfig.groovy&lt;/code&gt; file.  Obviously, &lt;a href=&quot;https://ant.apache.org/ivy/&quot;&gt;Ivy&lt;/a&gt; only knows about the dependencies declared
in the closures in &lt;code&gt;BuildConfig.groovy&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_build_scope_to_the_rescue&quot;&gt;Build Scope to the rescue&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;I decided that the best way to fix this was to make use of the &lt;code&gt;build&lt;/code&gt; dependency scope supported by &lt;a href=&quot;http://grails.org&quot;&gt;Grails&lt;/a&gt;/https://ant.apache.org/ivy/[Ivy], which does not allow the dependency to be included in the packaged artifact.  This first meant pushing
the &lt;a href=&quot;http://ckeditor.com/&quot;&gt;CKEditor&lt;/a&gt; builder JAR file into our &lt;a href=&quot;http://maven.apache.org/&quot;&gt;Maven&lt;/a&gt; repository and then adding the following to the &lt;code&gt;dependencies&lt;/code&gt; block in &lt;code&gt;BuildConfig.groovy&lt;/code&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;BuildConfig.groovy&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;grails.project.dependency.resolution = {

    ...

    dependencies {
        // Required to build/package ckeditor
        build &apos;com.ckeditor:ckbuilder:1.6.1&apos;

        ...
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The next step was to modify the &lt;a href=&quot;http://gant.codehaus.org/&quot;&gt;Gant&lt;/a&gt; script that we wrote to perform the &lt;a href=&quot;http://ckeditor.com/&quot;&gt;CKEditor&lt;/a&gt; compilation to programmatically invoke the &lt;a href=&quot;http://ckeditor.com/&quot;&gt;CKEditor&lt;/a&gt; builder instead of executing a command:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;scripts/PackageCkeditor.groovy&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;import ckbuilder.ckbuilder

target(packageCkeditor: &quot;Packages the CKEditor for inclusion as a dependency.&quot;) {
    String srcPath  = &apos;web-app/js/ckeditor-source&apos;
    String destPath = &apos;web-app/js/ckeditor&apos;
    String version  = &apos;4.0.0&apos;

    grailsConsole.addStatus &quot;Compiling CKEditor from source...&quot;
    ckbuilder.main([&quot;--build&quot;, &quot;${myPluginDir}/${srcPath}/&quot;, &quot;${myPluginDir}/${destPath}&quot;, &quot;--version=${version}&quot;,
            &quot;--build-config&quot;, &quot;${myPluginDir}/${srcPath}/dev/builder/ddc-build-config.js&quot;, &quot;--overwrite&quot;, &quot;--skip-omitted-in-build-config&quot;] as String[])

    grailsConsole.updateStatus &quot;Moving compiled CKEditor to target directory...&quot;
    ant.move(file: &quot;${myPluginDir}/${destPath}/ckeditor&quot;,
             tofile: &quot;${myPluginDir}/${destPath}&quot;,
             overwrite: true)

    grailsConsole.updateStatus &quot;Removing CKEditor archive artifacts...&quot;
    ant.delete(file: &quot;${myPluginDir}/${destPath}/ckeditor_${version.toLowerCase()}.zip&quot;)
    ant.delete(file: &quot;${myPluginDir}/${destPath}/ckeditor_${version.toLowerCase()}.tar.gz&quot;)

    grailsConsole.updateStatus &quot;CKEditor successfully compiled and ready to deploy.&quot;
}

setDefaultTarget(packageCkeditor)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The example above makes use of the &lt;code&gt;main()&lt;/code&gt; method of the &lt;code&gt;ckeditor&lt;/code&gt; class provided by the builder to invoke the &lt;a href=&quot;http://ckeditor.com/&quot;&gt;CKEditor&lt;/a&gt; compilation.  I tested it out and noticed that
none of my console statements after the call to &lt;code&gt;main()&lt;/code&gt; were being executed.  I quickly realized that something in the &lt;a href=&quot;http://ckeditor.com/&quot;&gt;CKEditor&lt;/a&gt; code was executing &lt;code&gt;System.exit()&lt;/code&gt;, which in turn
ended up killing the &lt;a href=&quot;http://grails.org&quot;&gt;Grails&lt;/a&gt; process.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_open_only_in_case_of_emergency&quot;&gt;Open only in case of emergency&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;To avoid this premature exit, I decided to add a temporary custom &lt;code&gt;SecurityManager&lt;/code&gt; that does not allow exits to happen:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;scripts/PackageCkeditor.groovy&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;import ckbuilder.ckbuilder

target(packageCkeditor: &quot;Packages the CKEditor for inclusion as a dependency.&quot;) {
    String srcPath  = &apos;web-app/js/ckeditor-source&apos;
    String destPath = &apos;web-app/js/ckeditor&apos;
    String version  = &apos;4.0.0&apos;

    grailsConsole.addStatus &quot;Compiling CKEditor from source...&quot;

    /*
     * The CKEditor builder calls System.exit().  Therefore,
     * we need a custom security manager to prevent it from
     * killing the Grails process too.  The code below
     * saves off the current security manager, sets the JVM
     * to use the custom no-exits-allowed manager and then
     * restores it after attempting to build CKEditor.
     */
    def defaultSecurityManager = System.getSecurityManager()
    System.setSecurityManager(new NoExitSecurityManager())

    try {
        ckbuilder.main([&quot;--build&quot;, &quot;${myPluginDir}/${srcPath}/&quot;, &quot;${myPluginDir}/${destPath}&quot;, &quot;--version=${version}&quot;,
            &quot;--build-config&quot;, &quot;${myPluginDir}/${srcPath}/dev/builder/ddc-build-config.js&quot;, &quot;--overwrite&quot;, &quot;--skip-omitted-in-build-config&quot;] as String[])
    } catch (e) {
        if(!(e instanceof SecurityException)) {
            grailsConsole.addStatus(&quot;Failed to execute CKEditor build: ${e.getMessage()}&quot;)
        }
    } finally {
        // Restore the security manager
        System.setSecurityManager(defaultSecurityManager)
    }

    grailsConsole.updateStatus &quot;Moving compiled CKEditor to target directory...&quot;
    ant.move(file: &quot;${myPluginDir}/${destPath}/ckeditor&quot;,
             tofile: &quot;${myPluginDir}/${destPath}&quot;,
             overwrite: true)

    grailsConsole.updateStatus &quot;Removing CKEditor archive artifacts...&quot;
    ant.delete(file: &quot;${myPluginDir}/${destPath}/ckeditor_${version.toLowerCase()}.zip&quot;)
    ant.delete(file: &quot;${myPluginDir}/${destPath}/ckeditor_${version.toLowerCase()}.tar.gz&quot;)

    grailsConsole.updateStatus &quot;CKEditor successfully compiled and ready to deploy.&quot;
}

setDefaultTarget(packageCkeditor)

/**
 * Custom &quot;no exits allowed&quot; security manager implementation.
 */
class NoExitSecurityManager extends SecurityManager {

    @Override
    public void checkExit(int status) {
        throw new SecurityException(&apos;Exit not allowed.&apos;)
    }

    @Override
    public void checkPermission(Permission perm) {
        // Allow all!
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The revamped code above now uses a custom &lt;code&gt;SecurityManager&lt;/code&gt; that does not allow the exit to happen.  While this is not the cleanest approach (I would have liked to have modified the &lt;a href=&quot;http://ckeditor.com/&quot;&gt;CKEditor&lt;/a&gt;
builder code, but they have not open sourced the builder&amp;#8201;&amp;#8212;&amp;#8201;only the editor itself), it gets the job done.  Now, we can use the &lt;a href=&quot;http://ckeditor.com/&quot;&gt;CKEditor&lt;/a&gt; programmatically and let &lt;a href=&quot;https://ant.apache.org/ivy/&quot;&gt;Ivy&lt;/a&gt; manage the dependency
the dependency, ensure that it does not get included in the packaged artifact and still be able to compile the source as part of our builds.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
            </description>
        </item>
        <item>
            <title>Spring and Apache Curator</title>
            <link>http://jdpgrailsdev.github.io/blog//2014/02/19/spring_curator.html</link>
            <pubDate>Wed, 19 Feb 2014 00:00:00 -0500</pubDate>
            <guid isPermaLink="false">/2014/02/19/spring_curator.html</guid>
            <description>
                    &lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Recently, I have been working a lot with &lt;a href=&quot;http://zookeeper.apache.org/&quot;&gt;Apache ZooKeeper&lt;/a&gt;.  &lt;a href=&quot;http://zookeeper.apache.org/&quot;&gt;Apache ZooKeeper&lt;/a&gt; provides a Java-based driver, but it does leave a little bit to be desired.  In steps &lt;a href=&quot;http://curator.apache.org/&quot;&gt;Apache Curator&lt;/a&gt;, which was originally created and open-sourced
by &lt;a href=&quot;https://github.com/netflix/curator&quot;&gt;Neflix&lt;/a&gt; and is now maintained by Apache.  &lt;a href=&quot;http://curator.apache.org/&quot;&gt;Apache Curator&lt;/a&gt; uses a fluent-style syntax to making using &lt;a href=&quot;http://zookeeper.apache.org/&quot;&gt;Apache ZooKeeper&lt;/a&gt; much easier.  In particular, &lt;a href=&quot;http://curator.apache.org/&quot;&gt;Apache Curator&lt;/a&gt; contains a more robust client class that handles things such
as retry attempts, listeners and other utilities that would otherwise need to be manually wired up using the low-level Java-based driver.  In order to support the use of &lt;a href=&quot;http://curator.apache.org/&quot;&gt;Apache Curator&lt;/a&gt; within a Spring-based application,
I decided to create a library that makes it easy to define &lt;a href=&quot;http://curator.apache.org/&quot;&gt;Apache Curator&lt;/a&gt; clients in a Spring configuration for use in an application.  One of the thinks to know about the &lt;a href=&quot;http://curator.apache.org/&quot;&gt;Apache Curator&lt;/a&gt; client is that you only need one
per instance/ensemble of &lt;a href=&quot;http://zookeeper.apache.org/&quot;&gt;Apache ZooKeeper&lt;/a&gt;.  Therefore, using Spring to manage the injection of a Singleton bean into a class that needs access to the client is a perfect fit.  The repository can be found on
&lt;a href=&quot;https://github.com/jdpgrailsdev/spring-curator&quot;&gt;GitHub&lt;/a&gt;.  Please check it out and let me know what you think.  As always, contributions are welcome!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_future_enhancements&quot;&gt;Future Enhancements&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Currently, the &lt;a href=&quot;https://github.com/jdpgrailsdev/spring-curator&quot;&gt;spring-curator&lt;/a&gt; library only supports the definition, creation and injection of &lt;a href=&quot;http://curator.apache.org/&quot;&gt;Apache Curator&lt;/a&gt; client instances.  In the future, I would like to add the
following support to the &lt;code&gt;spring-curator&lt;/code&gt; library:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Support for registring custom retry policies&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Definition of the following via the Spring configuration:&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;LeaderLatch&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;LeaderSelector&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;*Mutex locks&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;*Barrier barriers&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;SharedCount&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;DistributedAtomicLong&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;PathChildrenCache&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;NodeCache&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;PersistentEphemeralNode&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;*Queue queues&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
            </description>
        </item>
        <item>
            <title>Grails 2.3, Maven and Local Repositories</title>
            <link>http://jdpgrailsdev.github.io/blog//2014/02/10/grails_maven_local_repo.html</link>
            <pubDate>Mon, 10 Feb 2014 00:00:00 -0500</pubDate>
            <guid isPermaLink="false">/2014/02/10/grails_maven_local_repo.html</guid>
            <description>
                    &lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;One of the great new features in &lt;a href=&quot;http://grails.org&quot;&gt;Grails&lt;/a&gt; 2.3 is the ability to use &lt;a href=&quot;http://www.eclipse.org/aether/&quot;&gt;Aether&lt;/a&gt; to resolve dependencies in place of Ivy.  This is great news if
you already use &lt;a href=&quot;http://maven.apache.org/&quot;&gt;Maven&lt;/a&gt; to build other projects, as it now means you can have predictable builds between your &lt;a href=&quot;http://grails.org&quot;&gt;Grails&lt;/a&gt; and non-http://grails.org[Grails] applications.  However, like
any new feature, there are a few rough edges.  I ran into one the other day when trying to determine why one of my &lt;a href=&quot;http://grails.org&quot;&gt;Grails&lt;/a&gt; applications was not picking up dependencies from the local &lt;a href=&quot;http://maven.apache.org/&quot;&gt;Maven&lt;/a&gt;
cache  (&lt;code&gt;~/.m2/repository&lt;/code&gt;).  After some digging around, I ran across &lt;a href=&quot;http://jira.grails.org/browse/GRAILS-10921&quot;&gt;this bug&lt;/a&gt;.  According to it, the mavenLocal directive in the
repositories section of &lt;code&gt;BuildConfig.groovy&lt;/code&gt; is not honored when using the &lt;a href=&quot;http://www.eclipse.org/aether/&quot;&gt;Aether&lt;/a&gt; resolver.  So that stinks.  I quickly realized that we could make the &lt;a href=&quot;http://grails.org&quot;&gt;Grails&lt;/a&gt; dependency resolver
DSL pick up the local &lt;a href=&quot;http://maven.apache.org/&quot;&gt;Maven&lt;/a&gt; repository by simply adding a new file-based repository:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;    repositories {
        inherits true // Whether to inherit repository definitions from plugins

        mavenRepo &quot;file://${System.getProperty(&apos;user.home&apos;)}/.m2/repository&quot;

        ...
    }&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This little hack will allow you to continue checking the local &lt;a href=&quot;http://maven.apache.org/&quot;&gt;Maven&lt;/a&gt; repository when using the &lt;a href=&quot;http://grails.org&quot;&gt;Grails&lt;/a&gt; command line tools and the &lt;a href=&quot;http://grails.org/doc/2.3.x/guide/introduction.html#whatsNew23&quot;&gt;Maven dependency resolution support&lt;/a&gt;
new to &lt;a href=&quot;http://grails.org&quot;&gt;Grails&lt;/a&gt; 2.3.  The nice thing about this is that when/if the issue is fixed so that the local &lt;a href=&quot;http://maven.apache.org/&quot;&gt;Maven&lt;/a&gt; repository is honored, this fix should not cause any issues.  Not long after I made this fix,
I went to build the application on &lt;a href=&quot;http://jenkins-ci.org/&quot;&gt;Jenkins&lt;/a&gt; and notice some more funny business with dependencies.  After some digging, I determined the issue was due to the fact that now that the
&lt;a href=&quot;http://grails.org&quot;&gt;Grails&lt;/a&gt; applications were using &lt;a href=&quot;http://maven.apache.org/&quot;&gt;Maven&lt;/a&gt; for dependency resolution and not Ivy, they were sharing one local dependency cache.  When the Jenkins job is a &lt;a href=&quot;http://maven.apache.org/&quot;&gt;Maven&lt;/a&gt; project, I typically choose
the option to create a repository per workspace, to avoid collisions between jobs.  With a &lt;a href=&quot;http://grails.org&quot;&gt;Grails&lt;/a&gt; job, you do not have this option.  The option that you do have is setting the
&lt;code&gt;grails.dependency.cache.dir&lt;/code&gt; build property to tell &lt;a href=&quot;http://grails.org&quot;&gt;Grails&lt;/a&gt; where to cache and look for local dependencies.  I decided to conditionally set this based on whether or not the application
was being built on Jenkins or not (the reason for this is that I already have it set in my local &lt;code&gt;~/.grails/settings.groovy&lt;/code&gt; to have a separate cache per application).  Once again,
I modified the BuildConfig.groovy file to contain the following logic:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;    final String localMavenRepo = System.getenv(&apos;JENKINS_HOME&apos;) ? &quot;${System.getenv(&apos;WORKSPACE&apos;)}/.m2/repository&quot; :
                                        &quot;${System.getProperty(&apos;user.home&apos;)}/.m2/repository&quot;

    ...

    /**
      * If the build is being executed on Jenkins, set up the ivy cache.  This
      * is important as Grails checks to see if this has been set before allowing
      * an override of the local Maven repository.
      */
    if(System.getenv(&apos;JENKINS_HOME&apos;)) {
        grails.dependency.cache.dir = localMavenRepo
    }

    grails.project.dependency.resolver = &quot;maven&quot; // or ivy
    grails.project.dependency.resolution = {
        pom true

        // inherit Grails&apos; default dependencies
        inherits(&quot;global&quot;) {
        }

        log &quot;error&quot; // log level of Ivy resolver, either &apos;error&apos;, &apos;warn&apos;, &apos;info&apos;, &apos;debug&apos; or &apos;verbose&apos;
        checksums false // Whether to verify checksums on resolve
        legacyResolve false // whether to do a secondary resolve on plugin installation, not advised and here for backwards compatibility
        localRepository = localMavenRepo

        repositories {
            inherits true // Whether to inherit repository definitions from plugins

            mavenRepo &quot;file://${localMavenRepo}&quot;

            ...
        }
    }

    ...&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;It&amp;#8217;s worth noting that in the example above, I not only set the &lt;code&gt;grails.dependency.cache.dir&lt;/code&gt; &lt;a href=&quot;http://grails.org&quot;&gt;Grails&lt;/a&gt; build property, but
I also set the &lt;code&gt;localRepository&lt;/code&gt; property of the dependency resolution DSL to ensure that the &lt;a href=&quot;http://maven.apache.org/&quot;&gt;Maven&lt;/a&gt; dependency resolution is using it both as a place to check
for dependencies AND a place to store the cached dependencies (see the &lt;a href=&quot;https://github.com/grails/grails-core/blob/2.3.x/grails-aether/src/main/groovy/org/codehaus/groovy/grails/resolve/maven/aether/AetherDependencyManager.groovy&quot;&gt;AetherDependencyManager.groovy&lt;/a&gt; source
file in the &lt;code&gt;grails-aether&lt;/code&gt; module for more details).  Now when the application builds on Jenkins, not only does it have a local &lt;a href=&quot;http://maven.apache.org/&quot;&gt;Maven&lt;/a&gt; repository as part of
the list of repositories, but that repository is stored in the workspace for the Jenkins build job.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
            </description>
        </item>
        <item>
            <title>Blog Makeover</title>
            <link>http://jdpgrailsdev.github.io/blog//2014/02/06/redesign.html</link>
            <pubDate>Sat, 8 Feb 2014 00:00:00 -0500</pubDate>
            <guid isPermaLink="false">/2014/02/06/redesign.html</guid>
            <description>
                    &lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In an attempt to get myself to start blogging more regularly, I have decided to re-do my blog (which has largely been dormant).  A few days ago,
I read an interesting blog post by &lt;a href=&quot;http://melix.github.io/blog//2014/02/hosting-jbake-github.html&quot;&gt;CÃ©dric Champeau&lt;/a&gt; about using &lt;a href=&quot;http://www.jbake.org&quot;&gt;JBake&lt;/a&gt; to generate
blog posts from &lt;a href=&quot;https://daringfireball.net/projects/markdown/&quot;&gt;Markdown&lt;/a&gt;, &lt;a href=&quot;http://www.methods.co.nz/asciidoc/&quot;&gt;AsciiDoc&lt;/a&gt; or HTML and publish them to &lt;a href=&quot;http://github.com&quot;&gt;GitHub&lt;/a&gt;.  The blog post is pretty straight forward and with some minor tweaks
I was able to give my blog a makeover.  Additionally, its much easier now to author and publish posts.  Over the next few weeks, I am going to continue
to make tweaks to give the blog my own style.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
            </description>
        </item>
        <item>
            <title>Relocation</title>
            <link>http://jdpgrailsdev.github.io/blog//2012/12/08/relocation.html</link>
            <pubDate>Sat, 8 Dec 2012 00:00:00 -0500</pubDate>
            <guid isPermaLink="false">/2012/12/08/relocation.html</guid>
            <description>
                    &lt;p&gt;I have decided to relocate my blog from &lt;a href=&quot;http://jonathan-whywecanthavenicethings.blogspot.com&quot;&gt;Blog Spot&lt;/a&gt; to &lt;a href=&quot;http://jdpgrailsdev.github.io/blog&quot;&gt;GitHub&lt;/a&gt;. I have not actively posted anything in a while, but I am going to start&lt;br/&gt;up again and felt that hosting it on Github was a better choice. I will leave the old blog up with a pointer over to the new blog.&lt;/p&gt;
            </description>
        </item>
    </channel>
</rss>
