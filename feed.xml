<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>The Flowers Are Still Standing</title>
        <link>http://jdpgrailsdev.github.io/blog/</link>
        <atom:link href="http://jdpgrailsdev.github.io/blog//feed.xml" rel="self" type="application/rss+xml" />
        <description>Jonathan Pearlin's Blog</description>
        <language>en-us</language>
        <pubDate>Mon, 24 Oct 2016 08:18:04 -0700</pubDate>
        <lastBuildDate>Mon, 24 Oct 2016 08:18:04 -0700</lastBuildDate>
        <image>
            <url>http://jdpgrailsdev.github.io/blog//img/robot_devil.png</url>
            <title>Jonathan Pearlin's Blog</title>
            <link>http://jdpgrailsdev.github.io/blog/</link>
        </image>
        <item>
            <title>Testing a custom Gradle plugin with Gradle Test Kit</title>
            <link>http://jdpgrailsdev.github.io/blog/2016/03/29/gradle_test_kit.html</link>
            <pubDate>Tue, 29 Mar 2016 00:00:00 -0700</pubDate>
            <guid isPermaLink="false">2016/03/29/gradle_test_kit.html</guid>
            <description>
                    &lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;With the release of &lt;a href=&quot;https://gradle.org/&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; 2.10, the &lt;a href=&quot;https://docs.gradle.org/current/userguide/test_kit.html&quot; target=&quot;_blank&quot;&gt;Gradle Test Kit&lt;/a&gt; was included as an &quot;incubating&quot; feature to &quot;[aid] in testing  Gradle plugins and build logic generally.&quot;  Prior
to the creation of the &lt;a href=&quot;https://docs.gradle.org/current/userguide/test_kit.html&quot; target=&quot;_blank&quot;&gt;Gradle Test Kit&lt;/a&gt;, it had been fairly cumbersome to test custom &lt;a href=&quot;https://gradle.org/&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; plugins.  Tests often involved using the &lt;a href=&quot;https://docs.gradle.org/current/javadoc/org/gradle/testfixtures/ProjectBuilder.html&quot;&gt;ProductBuilder&lt;/a&gt;
to create a dummy instance of a &lt;code&gt;Project&lt;/code&gt; and retrieving a declared &lt;code&gt;Task&lt;/code&gt; and executing it manually.  While this would test the task logic directly, it did not test the execution of the task as part of a
normal &lt;a href=&quot;https://gradle.org/&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; execution.  Furthermore, it would not exercise task-based caching, making it hard to verify that any configured inputs/outputs are being honored.  This is where the &lt;a href=&quot;https://docs.gradle.org/current/userguide/test_kit.html&quot; target=&quot;_blank&quot;&gt;Gradle Test Kit&lt;/a&gt; can help.
It is focused on functional testing, which means that it emulates what a user will see when attempting to run tasks via the command line or &lt;a href=&quot;https://gradle.org/&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; wrapper.  Being an &quot;incubating&quot; feature, however, some of
the documentation is lacking, especially when it comes to testing a custom &lt;a href=&quot;https://gradle.org/&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; plugin within the project that contains the plugin definition and source.  In this post, we will explore how to set up
your custom plugin&amp;#8217;s project to use the &lt;a href=&quot;https://docs.gradle.org/current/userguide/test_kit.html&quot; target=&quot;_blank&quot;&gt;Gradle Test Kit&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_using_the_gradle_test_kit&quot;&gt;Using the Gradle Test Kit&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The first step is to include the &lt;a href=&quot;https://docs.gradle.org/current/userguide/test_kit.html&quot; target=&quot;_blank&quot;&gt;Gradle Test Kit&lt;/a&gt; as a &lt;code&gt;test&lt;/code&gt; scoped dependency in your project&amp;#8217;s &lt;code&gt;build.gradle&lt;/code&gt; file:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;dependencies {
  ...

  testCompile gradleTestKit()
  testCompile &apos;org.spockframework:spock-core:1.0-groovy-2.4&apos;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This will pull in the &lt;a href=&quot;https://docs.gradle.org/current/userguide/test_kit.html&quot; target=&quot;_blank&quot;&gt;Gradle Test Kit&lt;/a&gt; libraries for use during the &lt;code&gt;test&lt;/code&gt; phase of your project.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_creating_the_plugin_classpath&quot;&gt;Creating the Plugin Classpath&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The next step, which is hard to determine from the documentation, is to make sure that custom plugin and its descriptor are on the classpath path when using the &lt;a href=&quot;https://docs.gradle.org/current/userguide/test_kit.html&quot; target=&quot;_blank&quot;&gt;Gradle Test Kit&lt;/a&gt;.  In its current form,
there is no easy way to pass/build this classpath as part of a &lt;a href=&quot;https://github.com/spockframework/spock&quot; target=&quot;_blank&quot;&gt;Spock Framework&lt;/a&gt; test at runtime.  The trick is to follow what is outlined in section 43.2.1 of the &lt;a href=&quot;https://docs.gradle.org/current/userguide/test_kit.html&quot; target=&quot;_blank&quot;&gt;Gradle Test Kit&lt;/a&gt; documentation, which outlines
how to create a text file containing the classpath to be used by the &lt;a href=&quot;https://docs.gradle.org/current/userguide/test_kit.html&quot; target=&quot;_blank&quot;&gt;Gradle Test Kit&lt;/a&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;task createPluginClasspath {
    def outputDir = file(&quot;${buildDir}/resources/test&quot;)

    inputs.files sourceSets.test.runtimeClasspath
    outputs.dir outputDir

    doLast {
        outputDir.mkdirs()
        file(&quot;${outputDir}/plugin-classpath.txt&quot;).text = sourceSets.test.runtimeClasspath.join(&apos;\n&apos;,)
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In the example above, we use the &lt;code&gt;runtime&lt;/code&gt; classpath of the &lt;code&gt;test&lt;/code&gt; configuration to generate the classpath list to be passed to the &lt;a href=&quot;https://docs.gradle.org/current/userguide/test_kit.html&quot; target=&quot;_blank&quot;&gt;Gradle Test Kit&lt;/a&gt; runner.  The example in the &lt;a href=&quot;https://docs.gradle.org/current/userguide/test_kit.html&quot; target=&quot;_blank&quot;&gt;Gradle Test Kit&lt;/a&gt; documentation
uses the &lt;code&gt;main&lt;/code&gt; configuration, which is fine if you don&amp;#8217;t need to provide any additional libraries for testing.  In my case, I needed to have some other custom plugins available for the functional test, but
did not want those dependencies to be on my main &lt;code&gt;compile&lt;/code&gt; or &lt;code&gt;runtime&lt;/code&gt; classpath.  If you don&amp;#8217;t want to have to manually call this task each time you test your project, you can add the following your
&lt;code&gt;build.gradle&lt;/code&gt; script to tie its execution to the &lt;code&gt;test&lt;/code&gt; task:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;test.dependsOn([&apos;createPluginClasspath&apos;])&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Now that we have a task to generate the plugin classpath text file, we need to use it as part of our test.  In the example below, the contents of the &lt;code&gt;plugin-classpath.txt&lt;/code&gt; file read, collected,
converted into &lt;code&gt;File&lt;/code&gt; objects and stored into a list:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;class MyPluginFunctionalSpec extends Specification {

    @Rule
    TemporaryFolder testProjectDir = new TemporaryFolder()

    File buildFile

    File propertiesFile

    List pluginClasspath

    def setup() {
        buildFile = testProjectDir.newFile(&apos;build.gradle&apos;)
        propertiesFile = testProjectDir.newFile(&apos;gradle.properties&apos;)
        pluginClasspath = getClass().classLoader.findResource(&apos;plugin-classpath.txt&apos;).readLines().collect { new File(it) }
    }

    ...&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The &lt;code&gt;pluginClasspath&lt;/code&gt; list will be passed to the &lt;a href=&quot;https://docs.gradle.org/current/userguide/test_kit.html&quot; target=&quot;_blank&quot;&gt;Gradle Test Kit&lt;/a&gt; runner via the &lt;code&gt;withPluginClasspath&lt;/code&gt; method of the builder, which we will see in a bit.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_building_the_functional_test&quot;&gt;Building the Functional Test&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Now that we have our classpath sorted out, the next step is to build test(s) to execute your custom plugin and task(s):&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;def &quot;test that when the custom plugin is applied to a project and the customTask is executed, the customTask completes successfully&quot;() {
    setup:
        buildFile &amp;lt;&amp;lt; &apos;&apos;&apos;
            plugins {
                id &apos;my-custom-plugin
            }

            dependencies {
                compile &apos;com.google.guava:guava:19.0&apos;
                compile &apos;joda-time:joda-time:2.9.2&apos;
                compile &apos;org.slf4j:slf4j-api:1.7.13&apos;

                runtime &apos;org.slf4j:log4j-over-slf4j:1.7.13&apos;

                testCompile &apos;org.spockframework:spock-core:1.0-groovy-2.4&apos;
            }

            repositories {
                mavenLocal()
                mavenCentral()
            }
        &apos;&apos;&apos;
    when:
        GradleRunner runner = GradleRunner.create()
            .withProjectDir(testProjectDir.getRoot())
            .withArguments(&apos;customTask&apos;, &apos;--stacktrace&apos;, &apos;--refresh-dependencies&apos;)
            .withPluginClasspath(pluginClasspath)
        BuildResult result =  runner.build()
    then:
        result.task(&apos;:customTask&apos;).getOutcome() == TaskOutcome.SUCCESS
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In the example above, notice that we build a full build script, which includes the application of our custom &lt;a href=&quot;https://gradle.org/&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; plugin, and output it to &lt;code&gt;buildFile&lt;/code&gt; created in the setup seen
previously.  This can be anything that you would do in a project&amp;#8217;s &lt;code&gt;build.gradle&lt;/code&gt; file.  You could even store these files in &lt;code&gt;src/test/resources&lt;/code&gt; and load and copy the contents of
these files from the classpath and write it out to the file to be provided to the &lt;a href=&quot;https://docs.gradle.org/current/userguide/test_kit.html&quot; target=&quot;_blank&quot;&gt;Gradle Test Kit&lt;/a&gt; runner.  In the &lt;code&gt;when&lt;/code&gt; block, we see the &lt;a href=&quot;https://docs.gradle.org/current/userguide/test_kit.html&quot; target=&quot;_blank&quot;&gt;Gradle Test Kit&lt;/a&gt; in action.  Here, we set
the project directory to the &lt;code&gt;TemporaryFolder&lt;/code&gt; that will contain the &lt;code&gt;build.gradle&lt;/code&gt; file, the arguments to be passed to &lt;a href=&quot;https://gradle.org/&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; (e.g. the task(s) and switches), and the plugin
classpath we generated in the setup.  Without the plugin classpath, you will see errors related to &lt;a href=&quot;https://gradle.org/&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; being unable to locate any plugins that match your custom plugin&amp;#8217;s
ID.  Finally, in the &lt;code&gt;then&lt;/code&gt; block, we see that we test to make sure the status of the task execution is the one we expected.  You can also inspect the output of the build by
inspecting the &lt;code&gt;output&lt;/code&gt; field of the &lt;code&gt;BuildResult&lt;/code&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;result.output.contains(&apos;some text&apos;) == true&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This is also useful for debugging, as you can print out the contents of the result output to see the full output of the &lt;a href=&quot;https://gradle.org/&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; execution.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_test_failures_and_xerces&quot;&gt;Test Failures and Xerces&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Depending on what is on your plugin classpath, you may have tests fail due to issues related to the Xerces library.  This is often due to multiple versions of Xerces being present
on the classpath when the runner is executed and can be remedied by excluding Xerces from the generated classpath:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;pluginClasspath = getClass().classLoader.findResource(&apos;plugin-classpath.txt&apos;).readLines().collect { new File(it) }.findAll { !it.name.contains(&apos;xercesImpl&apos;) }&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Notice that we added a step to find all the classpath entries that do not contain the string &lt;code&gt;xercesImpl&lt;/code&gt; to ensure that we do not end up with duplicate Xerces
implementations on the classpath provided to the test kit runner.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_summary&quot;&gt;Summary&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The &lt;a href=&quot;https://docs.gradle.org/current/userguide/test_kit.html&quot; target=&quot;_blank&quot;&gt;Gradle Test Kit&lt;/a&gt; provides an excellent way to functionally test your custom &lt;a href=&quot;https://gradle.org/&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; plugins.  Because it uses actual build scripts, it is easy to build up a library of configurations
that you want to continually test as changes are made to the custom plugin.  Furthermore, the &lt;a href=&quot;https://docs.gradle.org/current/userguide/test_kit.html&quot; target=&quot;_blank&quot;&gt;Gradle Test Kit&lt;/a&gt; drastically reduces the amount of test code that you need to write,
allowing you to more efficiently test your plugin.  All of these are great reasons to convert your plugin tests to use the &lt;a href=&quot;https://docs.gradle.org/current/userguide/test_kit.html&quot; target=&quot;_blank&quot;&gt;Gradle Test Kit&lt;/a&gt; or to write tests for the first time
if you don&amp;#8217;t currently have test coverage for your code.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
            </description>
        </item>
        <item>
            <title>Using Spock/CGLIB with Java 8 and Gradle</title>
            <link>http://jdpgrailsdev.github.io/blog/2015/08/18/java_8_spock_cglib_gradle.html</link>
            <pubDate>Tue, 18 Aug 2015 00:00:00 -0700</pubDate>
            <guid isPermaLink="false">2015/08/18/java_8_spock_cglib_gradle.html</guid>
            <description>
                    &lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Recently, I attempted to convert a project that uses &lt;a href=&quot;https://github.com/cglib/cglib&quot; target=&quot;_blank&quot;&gt;CGLIB&lt;/a&gt; and &lt;a href=&quot;https://github.com/spockframework/spock&quot; target=&quot;_blank&quot;&gt;Spock Framework&lt;/a&gt; to execute unit tests to use Java 8 source
and target versions.  When I went to run the unit tests, I was met with a nasty &lt;code&gt;java.lang.IllegalArgumentException&lt;/code&gt;.  Some
quick internet searching showed that there is an existing issue with the currently released version of &lt;a href=&quot;https://github.com/cglib/cglib&quot; target=&quot;_blank&quot;&gt;CGLIB&lt;/a&gt; and the
version of the &lt;a href=&quot;https://github.com/llbit/ow2-asm&quot; target=&quot;_blank&quot;&gt;ASM&lt;/a&gt; library it depends on.  Despite  &lt;a href=&quot;https://github.com/cglib/cglib/issues/8&quot; target=&quot;_blank&quot;&gt;pleas&lt;/a&gt;
from the community, an updated version of &lt;a href=&quot;https://github.com/cglib/cglib&quot; target=&quot;_blank&quot;&gt;CGLIB&lt;/a&gt; with Java 8 compatibility has not yet been released.  However, there are commits on the project&amp;#8217;s trunk
that add Java 8 compatibility.  Luckily, a quick look at the &lt;a href=&quot;https://github.com/spockframework/spock&quot; target=&quot;_blank&quot;&gt;Spock Framework&lt;/a&gt; source code showed me how to get around this issue.  The trick is to use &lt;a href=&quot;https://jitpack.io&quot; target=&quot;_blank&quot;&gt;JitPack.io&lt;/a&gt; as a Maven
repository in your build script to build a particular commit hash of the project and expose it as a dependency for your project.  After some digging through the
source, I determined that &lt;a href=&quot;https://github.com/cglib/cglib/commits/master&quot; target=&quot;_blank&quot;&gt;commit 52e118aca4&lt;/a&gt; is the proper one to use.
To use this version of &lt;a href=&quot;https://github.com/cglib/cglib&quot; target=&quot;_blank&quot;&gt;CGLIB&lt;/a&gt; in your &lt;code&gt;build.gradle&lt;/code&gt; file, you simply need to add the following:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;repositories {
    // ...
    maven { url &quot;https://jitpack.io&quot; }
}

dependencies {
    testCompile &apos;com.github.cglib:cglib:52e118aca4&apos;
    testCompile &apos;org.spockframework:spock-core:0.7-groovy-2.0&apos;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You can generate this information using &lt;a href=&quot;https://jitpack.io&quot; target=&quot;_blank&quot;&gt;JitPack.io&lt;/a&gt; itself by going to the following URL:  &lt;a href=&quot;https://jitpack.io/#cglib/cglib/52e118aca4&quot; class=&quot;bare&quot;&gt;https://jitpack.io/#cglib/cglib/52e118aca4&lt;/a&gt;.  Now, my project will get &lt;a href=&quot;https://jitpack.io&quot; target=&quot;_blank&quot;&gt;JitPack.io&lt;/a&gt;
to build the custom release of &lt;a href=&quot;https://github.com/cglib/cglib&quot; target=&quot;_blank&quot;&gt;CGLIB&lt;/a&gt; without me needing to build and push it into a repository!&lt;/p&gt;
&lt;/div&gt;
            </description>
        </item>
        <item>
            <title>Upload File from Classpath/In-Memory Using Spring RestTemplate</title>
            <link>http://jdpgrailsdev.github.io/blog/2015/04/21/spring_file_upload.html</link>
            <pubDate>Tue, 21 Apr 2015 00:00:00 -0700</pubDate>
            <guid isPermaLink="false">2015/04/21/spring_file_upload.html</guid>
            <description>
                    &lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;File uploads via an HTTP POST to an end point are pretty easy using the &lt;code&gt;RestTemplate&lt;/code&gt; and &lt;code&gt;FileResource&lt;/code&gt; classes of the &lt;a href=&quot;http://projects.spring.io/spring-framework/&quot; target=&quot;_blank&quot;&gt;Spring Framework&lt;/a&gt;.  However,
this approach assumes that the file to be uploaded resides on disk.  What happens if you want to dynamically create the uploaded file in
memory or want to use a file on the classpath?  The answer is to create a slight tweak to the &lt;code&gt;ByteArrayResource&lt;/code&gt; implementation so that
the proper from data header attributes are set in the POST body.  To do this, first extend the &lt;code&gt;ByteArrayResource&lt;/code&gt; so that you can set
the &lt;code&gt;filename&lt;/code&gt; of the resource:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class FileMessageResource extends ByteArrayResource {

    /**
     * The filename to be associated with the {@link MimeMessage} in the form data.
     */
    private final String filename;

    /**
     * Constructs a new {@link FileMessageResource}.
     * @param byteArray A byte array containing data from a {@link MimeMessage}.
     * @param filename The filename to be associated with the {@link MimeMessage} in
     * 	the form data.
     */
    public FileMessageResource(final byte[] byteArray, final String filename) {
        super(byteArray);
        this.filename = filename;
    }

    @Override
    public String getFilename() {
        return filename;
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Next, create your new resource and add it to the POST body.  From there, simply pass the POST body to the
&lt;code&gt;RestTemplate&lt;/code&gt; to send the file to the end point:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;final MultiValueMap&amp;lt;String,Object&amp;gt; data = new LinkedMultiValueMap&amp;lt;String,Object&amp;gt;();
data.add(&quot;file&quot;, new FileMessageResource(fileBytes, &quot;upload.txt&quot;));
final HttpEntity&amp;lt;MultiValueMap&amp;lt;String, Object&amp;gt;&amp;gt; requestEntity = new HttpEntity&amp;lt;MultiValueMap&amp;lt;String, Object&amp;gt;&amp;gt;(data);
final ResponseEntity&amp;lt;Map&amp;lt;String,String&amp;gt;&amp;gt; response = getRestTemplate().exchange(url, HttpMethod.POST, requestEntity, new ParameterizedTypeReference&amp;lt;Map&amp;lt;String,String&amp;gt;&amp;gt;() {});&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The result is a form POST to the end point with the proper section header:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code&gt;Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;upload.txt&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
            </description>
        </item>
        <item>
            <title>Load Testing with GPars and Google Guava</title>
            <link>http://jdpgrailsdev.github.io/blog/2015/04/07/gpars_guava_load_test.html</link>
            <pubDate>Tue, 7 Apr 2015 00:00:00 -0700</pubDate>
            <guid isPermaLink="false">2015/04/07/gpars_guava_load_test.html</guid>
            <description>
                    &lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;I set out a few days back to write a simple &lt;a href=&quot;http://groovy-lang.org/&quot; target=&quot;_blank&quot;&gt;Groovy&lt;/a&gt; script that would accomplish the following:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Send data to a &lt;a href=&quot;http://kafka.apache.org/&quot; target=&quot;_blank&quot;&gt;Kafka&lt;/a&gt; topic from X concurrent producers.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Run for a set duration&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Achieve a set number of sends per minute&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;To do so, I decided to use &lt;a href=&quot;http://www.gpars.org/guide/index.html&quot; target=&quot;_blank&quot;&gt;GPars Framework&lt;/a&gt;, which is a &quot;concurrency and parallelism library for Java and Groovy
that gives you a number of high-level abstractions for writing concurrent and parallel code in Groovy.&quot;  Additionally,
I decided to make use of the &lt;a href=&quot;https://github.com/google/guava&quot; target=&quot;_blank&quot;&gt;Google Guava&lt;/a&gt; &lt;a href=&quot;http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/util/concurrent/RateLimiter.html&quot; target=&quot;_blank&quot;&gt;RateLimiter&lt;/a&gt;
class to control how much data is produced.  The resulting script is pretty simple:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;@Grapes([
    @Grab(group=&apos;org.codehaus.gpars&apos;, module=&apos;gpars&apos;, version=&apos;1.2.1&apos;),
    @Grab(group=&apos;com.google.guava&apos;, module=&apos;guava&apos;, version=&apos;18.0&apos;),
    @GrabExclude(&apos;commons-logging:commons-logging&apos;)])

def cli = new CliBuilder(usage:&apos;groovy loadTest.groovy &apos;)
cli.p(longOpt:&apos;parallelism&apos;, args: 1, argName: &apos;parallelism&apos;, &apos;The number of producers to execute in parallel.  Defaults to 10.&apos;)
cli.d(longOpt:&apos;duration&apos;, args: 1, argName: &apos;duration&apos;, &apos;The duration of the test in minutes.  Defaults to 1 minute.&apos;)
cli.r(longOpt:&apos;target-rate&apos;, args: 1, argName: &apos;targetRate&apos;, &apos;The target aggregate rate of messages to be produced per minute.  Defaults to 60.&apos;)
cli.h(longOpt:&apos;help&apos;, &apos;Displays the usage information for this script.&apos;)

def run = { -&amp;gt;
    // Do the actual work here (e.g. publish a message, etc)
}

def setup = { -&amp;gt;
    // Do any pre-test setup here (e.g. retrieving data, configuration, etc)
}

def options = cli.parse(args)

if(options?.h) {
    cli.usage()
} else {
   def duration = options?.d ? TimeUnit.MINUTES.toMillis(options.d as long) :  TimeUnit.MINUTES.toMillis(1l)
   def parallelism = options?.p ?: 10
   def targetRate = options?.r ?: 60.0

   println &apos;***********************************************&apos;
   println &apos;Load Test&apos;
   println &quot;Test will run for ${TimeUnit.MILLISECONDS.toMinutes(duration)} minute(s) using ${parallelism} producers with a target rate of ${targetRate} messages per minute.&quot;

   setup()

   println &apos;Starting the test....&apos;

   def rateLimiter = RateLimiter.create((targetRate as double)/TimeUnit.MINUTES.toSeconds(1))
   def startTime = System.currentTimeMillis()
   def total = 0
   while((System.currentTimeMillis() - startTime) &amp;lt; duration) {
       GParsExecutorsPool.withPool(parallelism as int) { ExecutorService service -&amp;gt;
           (parallelism as int).times {
               rateLimiter.acquire()
               service.submit({ run() } as Runnable)
           }
           total += parallelism as int
       }
       println &quot;Test iteration complete.  Total sent so far: ${total}, ${TimeUnit.MILLISECONDS.toSeconds(duration - (System.currentTimeMillis() - startTime))} second(s) remaining.&quot;
   }
   println &apos;Test complete.&apos;
   System.exit(0)
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The key points in the script above is the use of the &lt;code&gt;GParsExecutorsPool&lt;/code&gt; to handle the creation of a configured thread pool and the inclusion of
the &lt;code&gt;RateLimiter&lt;/code&gt; to slow down the execution loop to meet the target rate.  Finally, all of this is done in a &lt;code&gt;while&lt;/code&gt; loop that keeps looping until
the requested duration has been achieved.  The end result is a simple script that allows you to generate concurrent request load at a target rate for
a set duration.&lt;/p&gt;
&lt;/div&gt;
            </description>
        </item>
        <item>
            <title>Configure Jetty to Listen on Multiple Ports in a Spring Boot Application</title>
            <link>http://jdpgrailsdev.github.io/blog/2015/03/10/spring_boot_jetty_multi_port.html</link>
            <pubDate>Tue, 10 Mar 2015 00:00:00 -0700</pubDate>
            <guid isPermaLink="false">2015/03/10/spring_boot_jetty_multi_port.html</guid>
            <description>
                    &lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The &lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt; &lt;a href=&quot;http://docs.spring.io/spring-boot/docs/current/reference/html/howto-embedded-servlet-containers.html#howto-configure-jetty&quot; target=&quot;_blank&quot;&gt;documentation&lt;/a&gt; and
&lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples/spring-boot-sample-jetty&quot; target=&quot;_blank&quot;&gt;sample applications&lt;/a&gt; contain good information and examples
of how to use &lt;a href=&quot;http://eclipse.org/jetty/&quot; target=&quot;_blank&quot;&gt;Jetty&lt;/a&gt; in a &lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt; application instead of the default embedded Apache Tomcat server.  However, the documentation and examples do not really address how to
customize &lt;a href=&quot;http://eclipse.org/jetty/&quot; target=&quot;_blank&quot;&gt;Jetty&lt;/a&gt; as in depth as the Tomcat examples.  Recently, I found the need to make a &lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt; application using &lt;a href=&quot;http://eclipse.org/jetty/&quot; target=&quot;_blank&quot;&gt;Jetty&lt;/a&gt; listen on multiple ports for incoming HTTP traffic.
While this is not necessarily a normal use case, it does come up often, especially when the need to listen for both HTTP and HTTPS traffic is a requirement.  In a
&lt;a href=&quot;http://jdpgrailsdev.github.io/blog/2014/10/07/spring_boot_jetty_thread_pool.html&quot; target=&quot;_blank&quot;&gt;previous post&lt;/a&gt;, I showed how to customize the embedded &lt;a href=&quot;http://eclipse.org/jetty/&quot; target=&quot;_blank&quot;&gt;Jetty&lt;/a&gt; server in order to
change the size of the thread pool used for incoming connections.  Just like the approach outlined in that post, the way to configure the embedded &lt;a href=&quot;http://eclipse.org/jetty/&quot; target=&quot;_blank&quot;&gt;Jetty&lt;/a&gt; server in your &lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt;
application to listen to multiple ports is very similar:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;@Bean
public JettyEmbeddedServletContainerFactory jettyEmbeddedServletContainerFactory(
        @Value(&quot;${server.port:8080}&quot;) final String mainPort,
        @Value(&quot;#{&apos;${server.secondary.ports}&apos;.split(&apos;,&apos;)}&quot;) final List&amp;lt;String&amp;gt; secondaryPorts) {

    final JettyEmbeddedServletContainerFactory factory =  new JettyEmbeddedServletContainerFactory(Integer.valueOf(mainPort));

    // Add customized Jetty configuration with non blocking connection handler
    factory.addServerCustomizers(new JettyServerCustomizer() {
        @Override
        public void customize(final Server server) {
            // Register an additional connector for each secondary port.
            for(final String secondaryPort : secondaryPorts) {
                final NetworkTrafficServerConnector connector = new NetworkTrafficServerConnector(server);
                connector.setPort(Integer.valueOf(secondaryPort));
                server.addConnector(connector);
            }

            // Additional configuration
        }
    });
    return factory;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The example above uses the &lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt; provided &lt;code&gt;JettyServerCustomizer&lt;/code&gt; to register additional &lt;code&gt;NetworkTrafficServerConnector&lt;/code&gt; instances for each
secondary port provided in the application&amp;#8217;s configuration.  Additionally, the &lt;code&gt;server.port&lt;/code&gt; &lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt; property is still used for the
main application port and is passed to the &lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt; &lt;code&gt;JettyEmbeddedServletContainerFactory&lt;/code&gt;, just as it would be if you simply included
the appropriate starter library and set the property, per the documentation.  Finally, the application configuration contains the following configuration
to make it all work:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;server:
  port: &quot;8000&quot;
  secondary:
    ports: &quot;8082,8083,8084&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;When the application starts up, you can confirm that it is indeed listening on the multiple ports by looking for the following in the output:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code&gt;2015-03-09 15:13:35.483  INFO 1416 --- [           main] o.eclipse.jetty.server.ServerConnector   : Started ServerConnector@121ee28d{HTTP/1.1}{0.0.0.0:8080}
2015-03-09 15:13:35.483  INFO 1416 --- [           main] o.e.j.s.NetworkTrafficServerConnector    : Started NetworkTrafficServerConnector@36d64b9{HTTP/1.1}{0.0.0.0:8082}
2015-03-09 15:13:35.487  INFO 1416 --- [           main] o.e.j.s.NetworkTrafficServerConnector    : Started NetworkTrafficServerConnector@e51235{HTTP/1.1}{0.0.0.0:8083}
2015-03-09 15:13:35.488  INFO 1416 --- [           main] o.e.j.s.NetworkTrafficServerConnector    : Started NetworkTrafficServerConnector@3f0e5608{HTTP/1.1}{0.0.0.0:8084}
2015-03-09 15:13:35.489  INFO 1416 --- [           main] .s.b.c.e.j.JettyEmbeddedServletContainer : Jetty started on port(s) 8080 (http/1.1), 8082 (http/1.1), 8083 (http/1.1), 8084 (http/1.1)
2015-03-09 15:13:35.491  INFO 1416 --- [           main] com.test.Application                     : Started Application in 5.346 seconds (JVM running for 12.321)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
            </description>
        </item>
    </channel>
</rss>
