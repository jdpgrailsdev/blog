<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>The Flowers Are Still Standing</title>
        <link>http://jdpgrailsdev.github.io/blog/</link>
        <atom:link href="http://jdpgrailsdev.github.io/blog//feed.xml" rel="self" type="application/rss+xml" />
        <description>Jonathan Pearlin's Blog</description>
        <language>en-us</language>
        <pubDate>Tue, 11 Nov 2014 07:47:26 -0800</pubDate>
        <lastBuildDate>Tue, 11 Nov 2014 07:47:26 -0800</lastBuildDate>
        <image>
            <url>http://jdpgrailsdev.github.io/blog//img/robot_devil.png</url>
            <title>Jonathan Pearlin's Blog</title>
            <link>http://jdpgrailsdev.github.io/blog/</link>
        </image>
        <item>
            <title>Auto Configure Health Indicators in Spring Boot</title>
            <link>http://jdpgrailsdev.github.io/blog/2014/11/11/spring_boot_health_indicators_auto_config.html</link>
            <pubDate>Tue, 11 Nov 2014 00:00:00 -0800</pubDate>
            <guid isPermaLink="false">2014/11/11/spring_boot_health_indicators_auto_config.html</guid>
            <description>
                    &lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Another great feature provided by &lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt; is the ability to expose &lt;a href=&quot;http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#production-ready-health&quot; target=&quot;_blank&quot;&gt;Spring Boot Custom Health Information&lt;/a&gt; about your application with very little effort.  The simple approach is to
implement the &lt;code&gt;HealthIndicator&lt;/code&gt; interface and register your custom indicator as a Spring bean (or have it be &lt;a href=&quot;http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/annotation/ComponentScan.html&quot; target=&quot;_blank&quot;&gt;component scanned&lt;/a&gt;).
This is great for one-off indicators or in small projects.  But what happens when you want to have a common set of health indicators that you can use in all of your services (after all, one of the
promises of &lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt; is that it makes it trivial to spin up new &quot;micro&quot; services)?  What do you do if not all of your services have the same components that need to be part of your suite of health indicators?  The solution
is to leverage the &lt;a href=&quot;http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#getting-started-first-application-auto-configuration&quot; target=&quot;_blank&quot;&gt;auto configuration&lt;/a&gt; infrastructure provided by &lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt;.  The first step
is to include the proper dependencies in your health indicator shared library:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;ext {
    springBootVersion = &apos;1.1.8.RELEASE&apos;
}

dependencies {
    compile &quot;org.springframework.boot:spring-boot-autoconfigure:${springBootVersion}&quot;
    compile &quot;org.springframework.boot:spring-boot-actuator:${springBootVersion}&quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The &lt;code&gt;spring-boot-autoconfigure&lt;/code&gt; dependency provides the annotations that we will use to mark our configuration as able to partake in auto configuration.  The &lt;code&gt;spring-boot-actuator&lt;/code&gt;
dependency provides the &lt;code&gt;HealthIndicator&lt;/code&gt; interface and other related classes needed to implement the health indicators.  The next step is to create a custom health indicator implementation:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint java language-java&quot;&gt;&lt;code&gt;import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.util.concurrent.TimeUnit;

import kafka.consumer.ConsumerConfig;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.actuate.health.Health;
import org.springframework.boot.actuate.health.HealthIndicator;

public class KafkaConsumerHealthIndicator implements HealthIndicator {

    private static final Logger log = LoggerFactory.getLogger(KafkaConsumerHealthIndicator.class);

    private final static Long TIMEOUT = TimeUnit.SECONDS.toMillis(3);

    private final String host;

    private final int port;

    public KafkaConsumerHealthIndicator(final ConsumerConfig consumerConfig) {
        this.host = consumerConfig.zkConnect().split(&quot;:&quot;)[0];
        this.port = Integer.valueOf(consumerConfig.zkConnect().split(&quot;:&quot;)[1]);
    }

    @Override
    public Health health() {
        Socket socket = null;

        try {
            socket = new Socket();
            socket.connect(new InetSocketAddress(host, port), TIMEOUT.intValue());
            return Health.up().build();
        } catch (final Exception e) {
            return Health.down(e).build();
        } finally {
            if (socket != null) {
                try {
                    socket.close();
                } catch (final IOException e) {
                    log.debug(&quot;Unable to close Kafka consumer socket.&quot;, e);
                }
            }
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In this example, the health indicator attempts to make a socket connection to the connection string provided by the Kafka &lt;code&gt;ConsumerConfig&lt;/code&gt;.  It&amp;#8217;s a simple test to see if
ZooKeeper is listening at the configured host/port.  The next step is to create an automatic configuration that will define and register this health indicator if the
presence of a bean of type &lt;code&gt;ConsumerConfig&lt;/code&gt; is detected:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint java language-java&quot;&gt;&lt;code&gt;import java.util.Map;

import kafka.consumer.ConsumerConfig;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.actuate.autoconfigure.EndpointAutoConfiguration;
import org.springframework.boot.actuate.autoconfigure.HealthIndicatorAutoConfiguration;
import org.springframework.boot.actuate.health.CompositeHealthIndicator;
import org.springframework.boot.actuate.health.HealthAggregator;
import org.springframework.boot.actuate.health.HealthIndicator;
import org.springframework.boot.autoconfigure.AutoConfigureAfter;
import org.springframework.boot.autoconfigure.AutoConfigureBefore;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
import org.springframework.boot.autoconfigure.condition.ConditionalOnExpression;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@AutoConfigureBefore({ EndpointAutoConfiguration.class })
@AutoConfigureAfter({ HealthIndicatorAutoConfiguration.class })
public class CustomHealthIndicatorAutoConfiguration {

    /**
     * Configuration for Kafka consumer health indicators.
     *
     * @author jpearlin
     * @since 1.0.0
     */
    @Configuration
    @ConditionalOnBean(ConsumerConfig.class)
    @ConditionalOnExpression(&quot;${health.kafka.consumer.enabled:true}&quot;)
    public static class KafkaConsumerHealthIndicatorConfiguration {

        @Autowired
        private HealthAggregator healthAggregator;

        @Autowired(required = false)
        private Map&amp;lt;String, ConsumerConfig&amp;gt; consumerConfigs;

        @Bean
        @ConditionalOnMissingBean(name = &quot;kafkaConsumerHealthIndicator&quot;)
        public HealthIndicator kafkaConsumerHealthIndicator() {
            if (this.consumerConfigs.size() == 1) {
                return new KafkaConsumerHealthIndicator(this.consumerConfigs.values().iterator().next());
            }

            final CompositeHealthIndicator composite = new CompositeHealthIndicator(this.healthAggregator);
            for (final Map.Entry&amp;lt;String, ConsumerConfig&amp;gt; entry : this.consumerConfigs.entrySet()) {
                composite.addHealthIndicator(entry.getKey(), new KafkaConsumerHealthIndicator(entry.getValue()));
            }
            return composite;
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This auto configuration ensures that it is enabled after the default &lt;code&gt;HealthIndicatorAutoConfiguration&lt;/code&gt; provided by the &lt;code&gt;spring-boot-actuator&lt;/code&gt; dependency has been
loaded.  It also defines one Spring &lt;code&gt;Configuration&lt;/code&gt; that is conditionally loaded based on the presence of a bean of type &lt;code&gt;ConsumerConfig&lt;/code&gt;.  It can also be manually
disabled by setting the &lt;code&gt;health.kafka.consumer.enabled&lt;/code&gt; property to &lt;code&gt;false&lt;/code&gt;.  The configuration also ensures that if more than one bean of type &lt;code&gt;ConsumerConfig&lt;/code&gt; is
present, a &lt;code&gt;CompositeHealthIndicator&lt;/code&gt; is created.  The final piece required to tie all of this together is to provide Spring with the required metadata file that
instructs it on which classes represent auto-configuration.  To do this, create a file named &lt;code&gt;spring.factories&lt;/code&gt; in the &lt;code&gt;src/main/resources/META-INF&lt;/code&gt; directory of
your shared health indicator library:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.example.health.autoconfigure.CustomHealthIndicatorAutoConfiguration&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt; will automatically scan for these metadata files when your application starts and register your custom auto configuration class to be enacted if it detects
the &lt;code&gt;EnableAutoConfiguration&lt;/code&gt; annotation on any of your Java-based configuration classes.  Now you can provide a full suite of health indicators that will be enabled if
and only if certain conditions are met, as defined by the various configurations provided by your auto-configuration class!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
            </description>
        </item>
        <item>
            <title>Use connection parameters in Groovy with URL getText()</title>
            <link>http://jdpgrailsdev.github.io/blog/2014/11/04/groovy_url_text_params.html</link>
            <pubDate>Tue, 4 Nov 2014 00:00:00 -0800</pubDate>
            <guid isPermaLink="false">2014/11/04/groovy_url_text_params.html</guid>
            <description>
                    &lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;A while back, I wrote a &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; plugin that would query the &lt;a href=&quot;http://maven.apache.org/&quot; target=&quot;_blank&quot;&gt;Maven&lt;/a&gt; metadata for an artifact in order to automatically determine the next version number
for a sub-model artifact in a project.  To do so, I used the following code to retrieve and parse the &lt;a href=&quot;http://maven.apache.org/&quot; target=&quot;_blank&quot;&gt;Maven&lt;/a&gt; XML metadata:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;String url = &quot;${repository.url}/${project.group.replaceAll(&apos;\\.&apos;,&apos;/&apos;)}/${getProjectName(project)}/maven-metadata.xml&quot;
GPathResult metadata = xmlSlurper.parseText(url.toURL().text)
latestReleaseVersion = metadata.versioning.release&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The above code works great, until you run it in a scenario where you cannot connect to the URL provided by the repository.  When this happens, the code
waits a long time to determine that the connection cannot be established (as it is using the &lt;code&gt;URL&lt;/code&gt; defaults provided by Java for the connection and read
timeouts).  To make this fail faster in the scenarios, I followed some pointers provided by &lt;a href=&quot;http://mrhaki.blogspot.com/2011/09/groovy-goodness-use-connection.html&quot; target=&quot;_blank&quot;&gt;Mr. Haki&lt;/a&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;String url = &quot;${repository.url}/${project.group.replaceAll(&apos;\\.&apos;,&apos;/&apos;)}/${getProjectName(project)}/maven-metadata.xml&quot;
GPathResult metadata = xmlSlurper.parseText(url.toURL().getText(connectTimetout: TimeUnit.SECONDS.toMillis(10), readTimeout: TimeUnit.SECONDS.toMillis(60))))
latestReleaseVersion = metadata.versioning.release&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;As of &lt;a href=&quot;http://groovy.codehaus.org/&quot; target=&quot;_blank&quot;&gt;Groovy&lt;/a&gt; 1.8.1, you can pass the underlying &lt;code&gt;URLConnection&lt;/code&gt;&apos;s parameters to the &lt;code&gt;getText&lt;/code&gt; method.  In the example above, we have passed both the &lt;code&gt;connectTimeout&lt;/code&gt;
and &lt;code&gt;readTimeout&lt;/code&gt; to the &lt;code&gt;getText&lt;/code&gt; method to control when the connection will give up.  This ensures that the code will now fail faster in those offline scenarios.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
            </description>
        </item>
        <item>
            <title>Gradle Task to Resolve (Download) All Configured Dependencies</title>
            <link>http://jdpgrailsdev.github.io/blog/2014/10/28/gradle_resolve_all_dependencies.html</link>
            <pubDate>Tue, 28 Oct 2014 00:00:00 -0700</pubDate>
            <guid isPermaLink="false">2014/10/28/gradle_resolve_all_dependencies.html</guid>
            <description>
                    &lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;I had a challenge recently that involved being able to run a set of &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; tasks in a &lt;a href=&quot;https://www.docker.com/&quot; target=&quot;_blank&quot;&gt;Docker&lt;/a&gt; container that
did not have access to my artifact repository.  The obvious solution is to use the &lt;code&gt;--offline&lt;/code&gt; switch provided
by &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt;, but this only works if you have all the artifacts need to run cached locally.  When &lt;a href=&quot;https://www.docker.com/&quot; target=&quot;_blank&quot;&gt;Docker&lt;/a&gt;
builds its container, you can run any number of commands to populate it with whatever you need.  I decided to
create a simple &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; task to walk through each project in the source that I had copied into the &lt;a href=&quot;https://www.docker.com/&quot; target=&quot;_blank&quot;&gt;Docker&lt;/a&gt;
container that would force resolve each declared dependency:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;task resolveDependencies {
    doLast {
        project.rootProject.allprojects.each { subProject -&amp;gt;
            subProject.buildscript.configurations.each { configuration -&amp;gt;
                configuration.resolve()
            }
            subProject.configurations.each { configuration -&amp;gt;
                configuration.resolve()
            }
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; task above walks through each configuration defined in each sub-project in the &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; project and forces
&lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; to &quot;resolve&quot; (download) the artifacts.  Because it uses the &lt;code&gt;rootProject&lt;/code&gt;, this task can be defined in any
of the sub-projects.  After running this task, the &lt;a href=&quot;https://www.docker.com/&quot; target=&quot;_blank&quot;&gt;Docker&lt;/a&gt; container now has a primed &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; cache that allows me
to run the task in the container in offline mode!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
            </description>
        </item>
        <item>
            <title>Bash Function to Prune Merged/Deleted Remote Branches in GitHub</title>
            <link>http://jdpgrailsdev.github.io/blog/2014/10/21/github_prune_merged_branch.html</link>
            <pubDate>Tue, 21 Oct 2014 00:00:00 -0700</pubDate>
            <guid isPermaLink="false">2014/10/21/github_prune_merged_branch.html</guid>
            <description>
                    &lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;If you use &lt;a href=&quot;http://github.com&quot; target=&quot;_blank&quot;&gt;GitHub&lt;/a&gt; or any &lt;a href=&quot;http://git-scm.com/&quot; target=&quot;_blank&quot;&gt;Git&lt;/a&gt;-related tool that supports pull requests, you probably find yourself constantly
deleting, pruning and merging branches to get your feature code into your main development branch.  After doing
this over and over, I decided there must be a simple way using bash to put together a function that would
automate these steps:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Check out the master branch (or whatever your mainline development branch is)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Fetch all remote branches&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pull updates to the master branch&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Prune remote branches that have been deleted&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Delete my local copy of the feature branch that has been merged to master&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;I started with adding &lt;a href=&quot;http://git-scm.com/&quot; target=&quot;_blank&quot;&gt;Git&lt;/a&gt; status information to my shell by following
&lt;a href=&quot;http://www.newfinds.com/Ramblings/Bash-Promt/&quot; target=&quot;_blank&quot;&gt;these instructions&lt;/a&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;function parse_git_dirty {
  [[ $(git status 2&amp;gt; /dev/null | tail -n1) != &quot;nothing to commit, working directory clean&quot; ]] &amp;amp;&amp;amp; echo &quot; *&quot;
}

function parse_git_branch () {
  git branch 2&amp;gt; /dev/null | sed -e &apos;/^[^*]/d&apos; -e &quot;s/* \(.*\)/ (\1$(parse_git_dirty))/&quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Next, I added a new function to use the current branch (the one being merged/deleted/pruned) to turn
the steps mentioned above into a command:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;function prune_merged_branch () {
    prunedBranch=`echo &quot;$(parse_git_branch)&quot; | sed -e &apos;s/(//g&apos; | sed -e &apos;s/)//g&apos; | tr -d &apos; &apos;`
    git checkout master;git fetch --all;git pull;git remote prune origin;git branch -D &quot;$prunedBranch&quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Now, I can run &lt;code&gt;prune_merged_branch&lt;/code&gt; from the command line to do all of these steps in one swoop:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;$ prune_merged_branch
Switched to branch &apos;master&apos;
Your branch is up-to-date with &apos;origin/master&apos;.
Fetching origin
remote: Counting objects: 1, done.
remote: Total 1 (delta 0), reused 0 (delta 0)
Unpacking objects: 100% (1/1), done.
From https://github.com/&amp;lt;username&amp;gt;/&amp;lt;repo&amp;gt;
   a29de3b..b10695c  master     -&amp;gt; origin/master
First, rewinding head to replay your work on top of it...
Fast-forwarded master to b10695cdd910f064964d10e4f6d3d9ac78e3c1c6.
Pruning origin
URL: https://github.com/&amp;lt;username&amp;gt;/&amp;lt;repo&amp;gt;.git
 * [pruned] origin/some-branch
Deleted branch some-branch (was 27da761).&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
            </description>
        </item>
        <item>
            <title>Include Git Commit Info in Spring Boot Application with Gradle</title>
            <link>http://jdpgrailsdev.github.io/blog/2014/10/14/spring_boot_gradle_git_info.html</link>
            <pubDate>Tue, 14 Oct 2014 00:00:00 -0700</pubDate>
            <guid isPermaLink="false">2014/10/14/spring_boot_gradle_git_info.html</guid>
            <description>
                    &lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;One great way to track where and when your application came from when building is into include source control information.  With &lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt;, this
functionality comes out of the box (more or less).  If you read the &lt;a href=&quot;http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#production-ready-git-commit-information&quot; target=&quot;_blank&quot;&gt;documentation&lt;/a&gt;,
it suggests using the the &lt;a href=&quot;https://github.com/ajoberstar/gradle-git&quot; target=&quot;_blank&quot;&gt;gradle-git plugin&lt;/a&gt; to generate this data at build time.  However, there is a simple way to do this using Groovy that
does not involve the use of a plugin:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;task generateGitProperties {
    doLast {
        try {
            def branch = &apos;git rev-parse --abbrev-ref HEAD&apos;.execute().text.trim()
            def revision = &apos;git rev-list --max-count 1 --timestamp HEAD&apos;.execute().text.trim()
            def commitHash = revision.split(&apos; &apos;).last()
            def timestamp = revision ? new java.util.Date(java.util.concurrent.TimeUnit.SECONDS.toMillis(revision.split(&apos; &apos;).first() as long)).format(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ssZ&quot;) : null

            File resourcesDir = new File(project.getBuildDir(), &apos;resources/main&apos;)
            File propertiesFile = new File(resourcesDir, &apos;git.properties&apos;)

            if(timestamp) {
                // The project may not have any resources, so create the directories and file
                if(!propertiesFile.exists()) {
                    resourcesDir.mkdirs()
                    propertiesFile.createNewFile()
                }
                propertiesFile.text = &quot;&quot;&quot;git.branch=${branch}
        git.commit.id=${commitHash}
        git.commit.time=${timestamp}
                &quot;&quot;&quot;
            } else {
               project.logger.error(&apos;Unable to generate Git properties file:  revision could not be retrieved from Git.&apos;)
            }
        } catch (e) {
            project.logger.error(&apos;Unable to generate Git properties file.&apos;, e)
        }
    }
}

...

// Generate the Git commit properties file prior to building the artifact
project.tasks.jar.dependsOn(&apos;generateGitProperties&apos;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The task above will include the &lt;code&gt;git.properties&lt;/code&gt; file in the packaged &lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt; JAR and can be accessed at the &lt;code&gt;/info&lt;/code&gt; servlet to see what branch and hash were
used to build your application.  It will also safely fail on systems that do not have Git installed or do not have Git on the path (such as if you try to execute
this task from inside an IDE).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
            </description>
        </item>
    </channel>
</rss>
