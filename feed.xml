<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>The Flowers Are Still Standing</title>
        <link>http://jdpgrailsdev.github.io/blog/</link>
        <atom:link href="http://jdpgrailsdev.github.io/blog//feed.xml" rel="self" type="application/rss+xml" />
        <description>Jonathan Pearlin's Blog</description>
        <language>en-us</language>
        <pubDate>Tue, 21 Oct 2014 08:22:17 -0700</pubDate>
        <lastBuildDate>Tue, 21 Oct 2014 08:22:17 -0700</lastBuildDate>
        <image>
            <url>http://jdpgrailsdev.github.io/blog//img/robot_devil.png</url>
            <title>Jonathan Pearlin's Blog</title>
            <link>http://jdpgrailsdev.github.io/blog/</link>
        </image>
        <item>
            <title>Bash Function to Prune Merged/Deleted Remote Branches in GitHub</title>
            <link>http://jdpgrailsdev.github.io/blog/2014/10/21/github_prune_merged_branch.html</link>
            <pubDate>Tue, 21 Oct 2014 00:00:00 -0700</pubDate>
            <guid isPermaLink="false">2014/10/21/github_prune_merged_branch.html</guid>
            <description>
                    &lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;If you use &lt;a href=&quot;http://github.com&quot; target=&quot;_blank&quot;&gt;GitHub&lt;/a&gt; or any &lt;a href=&quot;http://git-scm.com/&quot; target=&quot;_blank&quot;&gt;Git&lt;/a&gt;-related tool that supports pull requests, you probably find yourself constantly
deleting, pruning and merging branches to get your feature code into your main development branch.  After doing
this over and over, I decided there must be a simple way using bash to put together a function that would
automate these steps:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Check out the master branch (or whatever your mainline development branch is)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Fetch all remote branches&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pull updates to the master branch&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Prune remote branches that have been deleted&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Delete my local copy of the feature branch that has been merged to master&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;I started with adding &lt;a href=&quot;http://git-scm.com/&quot; target=&quot;_blank&quot;&gt;Git&lt;/a&gt; status information to my shell by following
&lt;a href=&quot;http://www.newfinds.com/Ramblings/Bash-Promt/&quot; target=&quot;_blank&quot;&gt;these instructions&lt;/a&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;function parse_git_dirty {
  [[ $(git status 2&amp;gt; /dev/null | tail -n1) != &quot;nothing to commit, working directory clean&quot; ]] &amp;amp;&amp;amp; echo &quot; *&quot;
}

function parse_git_branch () {
  git branch 2&amp;gt; /dev/null | sed -e &apos;/^[^*]/d&apos; -e &quot;s/* \(.*\)/ (\1$(parse_git_dirty))/&quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Next, I added a new function to use the current branch (the one being merged/deleted/pruned) to turn
the steps mentioned above into a command:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;function prune_merged_branch () {
    prunedBranch=`echo &quot;$(parse_git_branch)&quot; | sed -e &apos;s/(//g&apos; | sed -e &apos;s/)//g&apos; | tr -d &apos; &apos;`
    git checkout master;git fetch --all;git pull;git remote prune origin;git branch -D &quot;$prunedBranch&quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Now, I can run &lt;code&gt;prune_merged_branch&lt;/code&gt; from the command line to do all of these steps in one swoop:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;$ prune_merged_branch
Switched to branch &apos;master&apos;
Your branch is up-to-date with &apos;origin/master&apos;.
Fetching origin
remote: Counting objects: 1, done.
remote: Total 1 (delta 0), reused 0 (delta 0)
Unpacking objects: 100% (1/1), done.
From https://github.com/&amp;lt;username&amp;gt;/&amp;lt;repo&amp;gt;
   a29de3b..b10695c  master     -&amp;gt; origin/master
First, rewinding head to replay your work on top of it...
Fast-forwarded master to b10695cdd910f064964d10e4f6d3d9ac78e3c1c6.
Pruning origin
URL: https://github.com/&amp;lt;username&amp;gt;/&amp;lt;repo&amp;gt;.git
 * [pruned] origin/some-branch
Deleted branch some-branch (was 27da761).&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
            </description>
        </item>
        <item>
            <title>Include Git Commit Info in Spring Boot Application with Gradle</title>
            <link>http://jdpgrailsdev.github.io/blog/2014/10/14/spring_boot_gradle_git_info.html</link>
            <pubDate>Tue, 14 Oct 2014 00:00:00 -0700</pubDate>
            <guid isPermaLink="false">2014/10/14/spring_boot_gradle_git_info.html</guid>
            <description>
                    &lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;One great way to track where and when your application came from when building is into include source control information.  With &lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt;, this
functionality comes out of the box (more or less).  If you read the &lt;a href=&quot;http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#production-ready-git-commit-information&quot; target=&quot;_blank&quot;&gt;documentation&lt;/a&gt;,
it suggests using the the &lt;a href=&quot;https://github.com/ajoberstar/gradle-git&quot; target=&quot;_blank&quot;&gt;gradle-git plugin&lt;/a&gt; to generate this data at build time.  However, there is a simple way to do this using Groovy that
does not involve the use of a plugin:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;task generateGitProperties {
    doLast {
        try {
            def branch = &apos;git rev-parse --abbrev-ref HEAD&apos;.execute().text.trim()
            def revision = &apos;git rev-list --max-count 1 --timestamp HEAD&apos;.execute().text.trim()
            def commitHash = revision.split(&apos; &apos;).last()
            def timestamp = revision ? new java.util.Date(java.util.concurrent.TimeUnit.SECONDS.toMillis(revision.split(&apos; &apos;).first() as long)).format(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ssZ&quot;) : null

            File resourcesDir = new File(project.getBuildDir(), &apos;resources/main&apos;)
            File propertiesFile = new File(resourcesDir, &apos;git.properties&apos;)

            if(timestamp) {
                // The project may not have any resources, so create the directories and file
                if(!propertiesFile.exists()) {
                    resourcesDir.mkdirs()
                    propertiesFile.createNewFile()
                }
                propertiesFile.text = &quot;&quot;&quot;git.branch=${branch}
        git.commit.id=${commitHash}
        git.commit.time=${timestamp}
                &quot;&quot;&quot;
            } else {
               project.logger.error(&apos;Unable to generate Git properties file:  revision could not be retrieved from Git.&apos;)
            }
        } catch (e) {
            project.logger.error(&apos;Unable to generate Git properties file.&apos;, e)
        }
    }
}

...

// Generate the Git commit properties file prior to building the artifact
project.tasks.jar.dependsOn(&apos;generateGitProperties&apos;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The task above will include the &lt;code&gt;git.properties&lt;/code&gt; file in the packaged &lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt; JAR and can be accessed at the &lt;code&gt;/info&lt;/code&gt; servlet to see what branch and hash were
used to build your application.  It will also safely fail on systems that do not have Git installed or do not have Git on the path (such as if you try to execute
this task from inside an IDE).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
            </description>
        </item>
        <item>
            <title>Configure Jetty&amp;#8217;s Thread Pool in a Spring Boot Application</title>
            <link>http://jdpgrailsdev.github.io/blog/2014/10/07/spring_boot_jetty_thread_pool.html</link>
            <pubDate>Tue, 7 Oct 2014 00:00:00 -0700</pubDate>
            <guid isPermaLink="false">2014/10/07/spring_boot_jetty_thread_pool.html</guid>
            <description>
                    &lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In a &lt;a href=&quot;http://jonathanpearlin.com/blog/2014/09/30/spring_boot_jetty_jmx.html&quot; target=&quot;_blank&quot;&gt;previous post&lt;/a&gt;, I discussed how to use &lt;a href=&quot;http://www.eclipse.org/jetty/&quot; target=&quot;_blank&quot;&gt;Jetty&lt;/a&gt; as the servlet container in a &lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt; application over the default implementation
(Apache Tomcat) and also how to enable &lt;a href=&quot;http://www.eclipse.org/jetty/&quot; target=&quot;_blank&quot;&gt;Jetty&lt;/a&gt;&apos;s registered MBeans via JMX.  In addition to this configuration, you can also configure &lt;a href=&quot;http://www.eclipse.org/jetty/&quot; target=&quot;_blank&quot;&gt;Jetty&lt;/a&gt; so that it is not using the factory
default settings for the servlet container.  One setting that you typically want to control is the size of the thread pool used by &lt;a href=&quot;http://www.eclipse.org/jetty/&quot; target=&quot;_blank&quot;&gt;Jetty&lt;/a&gt; to service incoming requests.  This is
pretty easy to do with &lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt; by adding a &lt;a href=&quot;http://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/context/embedded/jetty/JettyServerCustomizer.html&quot; target=&quot;blank&quot;&gt;JettyServerCustomizer&lt;/a&gt; implementation
to gain access to &lt;a href=&quot;http://www.eclipse.org/jetty/&quot; target=&quot;_blank&quot;&gt;Jetty&lt;/a&gt;&apos;s &lt;code&gt;Server&lt;/code&gt; instance:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint java language-java&quot;&gt;&lt;code&gt;@Bean
public JettyEmbeddedServletContainerFactory jettyEmbeddedServletContainerFactory(@Value(&quot;${server.port:8080}&quot;) final String port,
            @Value(&quot;${jetty.threadPool.maxThreads:200}&quot;) final String maxThreads,
            @Value(&quot;${jetty.threadPool.minThreads:8}&quot;) final String minThreads,
            @Value(&quot;${jetty.threadPool.idleTimeout:60000}&quot;) final String idleTimeout) {
    final JettyEmbeddedServletContainerFactory factory =  new JettyEmbeddedServletContainerFactory(Integer.valueOf(port));
    factory.addServerCustomizers(new JettyServerCustomizer() {
        @Override
        public void customize(final Server server) {
            // Tweak the connection pool used by Jetty to handle incoming HTTP connections
            final QueuedThreadPool threadPool = server.getBean(QueuedThreadPool.class);
            threadPool.setMaxThreads(Integer.valueOf(maxThreads));
            threadPool.setMinThreads(Integer.valueOf(minThreads));
            threadPool.setIdleTimeout(Integer.valueOf(idleTimeout));
        }
    });
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In the example above, values (with defaults) are read from the Spring configuration and used to set the thread pool managed by &lt;a href=&quot;http://www.eclipse.org/jetty/&quot; target=&quot;_blank&quot;&gt;Jetty&lt;/a&gt;.  In order
to make this work, you must include the following dependencies with your application:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;ext {
    jettyVersion = &apos;9.0.3.v20130506&apos;
}

dependencies {
  ...

  compile &quot;org.eclipse.jetty:jetty-server:$jettyVersion&quot;
  compile &quot;org.eclipse.jetty:jetty-util:$jettyVersion&quot;

  ...
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This example can be extended to configure any bean registered with the &lt;a href=&quot;http://www.eclipse.org/jetty/&quot; target=&quot;_blank&quot;&gt;Jetty&lt;/a&gt; &lt;code&gt;Server&lt;/code&gt; instance.  To figure out what is available, connect to your running
application using a JMX console and view the beans exposed by &lt;a href=&quot;http://www.eclipse.org/jetty/&quot; target=&quot;_blank&quot;&gt;Jetty&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
            </description>
        </item>
        <item>
            <title>Expose Jetty MBeans via JMX in a Spring Boot Application</title>
            <link>http://jdpgrailsdev.github.io/blog/2014/09/30/spring_boot_jetty_jmx.html</link>
            <pubDate>Tue, 30 Sep 2014 00:00:00 -0700</pubDate>
            <guid isPermaLink="false">2014/09/30/spring_boot_jetty_jmx.html</guid>
            <description>
                    &lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt; provides monitoring and management over JMX &lt;a href=&quot;http://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-jmx.html&quot; target=&quot;_blank&quot;&gt;out of the box&lt;/a&gt;.  If you include a library
that exposes &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/jmx/mbeans/&quot; target=&quot;_blank&quot;&gt;MBeans&lt;/a&gt;, they will automatically be registered and exposed with the MBean server provided by &lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt;.  However, some packages don&amp;#8217;t enable their MBeans by default.  Jetty is one of those
libraries.  If you are using Jetty instead of Tomcat (Tomcat is the default option in &lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt;), you can enable Jetty&amp;#8217;s MBeans by adding a &lt;code&gt;customizer&lt;/code&gt; to a custom override of the &lt;code&gt;JettyEmbeddedServletContainerFactory&lt;/code&gt;
bean:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint java language-java&quot;&gt;&lt;code&gt;@Bean
public JettyEmbeddedServletContainerFactory jettyEmbeddedServletContainerFactory(@Value(&quot;${server.port:8080}&quot;) final String port) {
    final JettyEmbeddedServletContainerFactory factory =  new JettyEmbeddedServletContainerFactory(Integer.valueOf(port));
    factory.addServerCustomizers(new JettyServerCustomizer() {
        @Override
        public void customize(final Server server) {
            // Expose Jetty managed beans to the JMX platform server provided by Spring
            final MBeanContainer mbContainer = new MBeanContainer(ManagementFactory.getPlatformMBeanServer());
            server.addBean(mbContainer);
        }
    });
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The code sample above will register Jetty&amp;#8217;s MBeans with the default platform MBean server (which is provided by &lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt;).  This will allow you to see things like the number of threads in use in Jetty&amp;#8217;s
connection pool and other fun facts that can be very useful when debugging Jetty or configuring it for better performance.  It is also worth noting that you will need to include the following dependencies
in order to expose the Jetty MBeans:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;ext {
    jettyVersion = &apos;9.0.3.v20130506&apos;
}

dependencies {
  ...

  compile &quot;org.eclipse.jetty:jetty-jmx:$jettyVersion&quot;
  compile &quot;org.eclipse.jetty:jetty-server:$jettyVersion&quot;
  compile &quot;org.eclipse.jetty:jetty-util:$jettyVersion&quot;

  ...
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
            </description>
        </item>
        <item>
            <title>Use Spring to Autodetect and Load JRuby Gem Dependencies</title>
            <link>http://jdpgrailsdev.github.io/blog/2014/09/23/spring_jruby_autodetect_deps.html</link>
            <pubDate>Tue, 23 Sep 2014 00:00:00 -0700</pubDate>
            <guid isPermaLink="false">2014/09/23/spring_jruby_autodetect_deps.html</guid>
            <description>
                    &lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;I decided recently to try to use &lt;a href=&quot;http://jruby.org/&quot; target=&quot;_blank&quot;&gt;JRuby&lt;/a&gt; to help me use Ruby-based libraries as plugins in a Java application.  This is pretty easy to do if your Ruby code makes use
of the stock modules included in &lt;a href=&quot;http://jruby.org/&quot; target=&quot;_blank&quot;&gt;JRuby&lt;/a&gt;.  However, what happens if the Ruby scripts need to access other libraries that typically would be found in external
&lt;a href=&quot;https://rubygems.org/&quot; target=&quot;_blank&quot;&gt;Ruby Gems&lt;/a&gt;?  One answer is to use &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt;, &lt;a href=&quot;http://jruby.org/&quot; target=&quot;_blank&quot;&gt;JRuby&lt;/a&gt; and the &lt;a href=&quot;http://spring.io&quot; target=&quot;_blank&quot;&gt;Spring Framework&lt;/a&gt; to automatically download, package and discover these dependencies at build and runtime.
Another way to put it is that we have three distinct operations that we need to perform in order to get all of this playing nicely together:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;Use &lt;a href=&quot;http://bundler.io/&quot; target=&quot;_blank&quot;&gt;Bundler&lt;/a&gt; to find, download and install all required Ruby modules at build time (&lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; + &lt;a href=&quot;http://jruby.org/&quot; target=&quot;_blank&quot;&gt;JRuby&lt;/a&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Package Ruby modules with Ruby script(s) in JAR file (&lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Auto-discover packaged Ruby modules at runtime and add them to the &quot;load path&quot; of the script that is to be executed (&lt;a href=&quot;http://jruby.org/&quot; target=&quot;_blank&quot;&gt;JRuby&lt;/a&gt; + &lt;a href=&quot;http://spring.io&quot; target=&quot;_blank&quot;&gt;Spring Framework&lt;/a&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Execute the script (&lt;a href=&quot;http://jruby.org/&quot; target=&quot;_blank&quot;&gt;JRuby&lt;/a&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Let&amp;#8217;s start with the first task:  Use &lt;a href=&quot;http://bundler.io/&quot; target=&quot;_blank&quot;&gt;Bundler&lt;/a&gt; to find, download and install all required Ruby modules at build time.  To accomplish this, I decided to
use custom tasks in a &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; script to first install &lt;a href=&quot;http://bundler.io/&quot; target=&quot;_blank&quot;&gt;Bundler&lt;/a&gt; and then use &lt;a href=&quot;http://bundler.io/&quot; target=&quot;_blank&quot;&gt;Bundler&lt;/a&gt; to install any required Ruby modules found in the project&amp;#8217;s &lt;code&gt;Gemfile&lt;/code&gt;.
This &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; script also needed to be able to copy the installed &lt;a href=&quot;https://rubygems.org/&quot; target=&quot;_blank&quot;&gt;Ruby Gems&lt;/a&gt; to a directory that would ensure their inclusion in the packaged JAR file.  Below
is the script:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;import groovy.util.AntBuilder

buildscript {
    dependencies {
        classpath &apos;org.jruby:jruby-complete:1.7.13&apos;
    }
}

jar {
    from (&quot;${project.projectDir}/src/main/ruby&quot;)
}

dependencies {
    runtime project(&apos;:shared&apos;)
}

sourceSets {
    main {
       java {
          srcDir file(&quot;${project.projectDir}/src/main/ruby&quot;)
       }
    }
}

/*
 * Installs Bundler to the project&apos;s build directory.  Bundler is used to
 * install any Gems required by this plugin.
 */
task installBundler(type:JavaExec, description:&apos;Installs Bundler&apos;) {
    args = &quot;--2.0 -S gem install -i ${project.buildDir}/bundler --no-rdoc --no-ri bundler&quot;.tokenize()
    classpath = project.buildscript.configurations.classpath
    jvmArgs(&quot;-Xmx800M&quot;)
    main = &apos;org.jruby.Main&apos;
    environment = [HOME:System.getProperty(&apos;user.home&apos;),
                    PATH:[&apos;/usr/local/bin&apos;, &apos;/usr/bin&apos;,&apos;/bin&apos;,&apos;/usr/sbin&apos;,&apos;/sbin&apos;].join(File.pathSeparator)]
    workingDir = project.projectDir
}

/*
 * Installs the Gems required by this plugin to the project&apos;s build directory.
 * This task uses Bundler to perform the Gem installations.
 */
task installGems(type:JavaExec, description:&apos;Installs all required Gems via Bundle.&apos;, dependsOn:&apos;installBundler&apos;) {
    args = &quot;--2.0 -S bundle install --path ${project.buildDir}&quot;.tokenize()
    classpath = project.buildscript.configurations.classpath
    main = &apos;org.jruby.Main&apos;
    environment = [GEM_PATH: &quot;${project.buildDir}/bundler&quot;,
                    HOME:System.getProperty(&apos;user.home&apos;),
                    PATH:[&quot;${project.buildDir}/bundler/bin&quot;, &apos;/usr/local/bin&apos;, &apos;/usr/bin&apos;,&apos;/bin&apos;,&apos;/usr/sbin&apos;,&apos;/sbin&apos;].join(File.pathSeparator)]
    workingDir = project.projectDir
}

/*
 * Moves the installed Gem files from the project&apos;s build directory to src/main/resources
 * so that they will be included in the packaged JAR.
 */
task packageGems(dependsOn:&apos;installGems&apos;) {
    doLast {
        Properties props = new Properties()
        props.load(new File(&quot;${project.projectDir}/src/main/resources/META-INF/notification/${project.name}.plugin&quot;).newDataInputStream())
        File parent = new File(&quot;${project.projectDir}/src/main/resources/${props.getProperty(&apos;plugin-name&apos;)}/gems&quot;)
        parent.deleteDir()
        parent.mkdirs()

        // Normalize each installed gem directory name and move it to src/main/resources
        new File(&quot;${project.buildDir}/jruby/1.9/gems&quot;).listFiles().each { file -&amp;gt;
            processSourceFiles(parent, new File(file, &apos;lib&apos;))
            File vendorGems = new File(file, &apos;vendor/gems&apos;)
            if(vendorGems.exists()) {
                vendorGems.listFiles().each { vendorFile -&amp;gt;
                    processSourceFiles(parent, new File(vendorFile, &apos;lib&apos;))
                }
            }
        }
    }
}

project.tasks.installGems.inputs.file(&quot;${project.projectDir}/Gemfile&quot;)
project.tasks.installGems.outputs.dir(&quot;${project.buildDir}/jruby&quot;)
project.tasks.installBundler.outputs.upToDateWhen { new File(&quot;${project.buildDir}/bundler&quot;).exists() }
project.tasks.jar.dependsOn([&apos;packageGems&apos;])

def processSourceFiles(File newParent, File rootDir) {
    File newRootDir = new File(newParent, rootDir.getParentFile().getName())
    new AntBuilder().copy(todir : newRootDir.getAbsolutePath(), quiet:true) {
        fileset(dir: rootDir.getAbsolutePath())
    }
    newRootDir.eachFileRecurse { rubyFile -&amp;gt;
        if(rubyFile.isFile() &amp;amp;&amp;amp; rubyFile.text.contains(&apos;require_relative&apos;)) {
            def builder = new StringBuilder()
            rubyFile.eachLine { line -&amp;gt;
                line = line.replaceAll(&apos;require_relative\\s+\&apos;\\.\\/(.+)\&apos;&apos;, &apos;require_relative \&apos;$1\&apos;&apos;)
                def matcher = line =~ /require_relative\s+&apos;((\.\.\/)+).+&apos;/
                if(matcher.find()) {
                    def numberOfParentDirs = matcher[0][1].split(&apos;/&apos;).length
                    def actualParent = rubyFile.getParentFile()
                    numberOfParentDirs.times { actualParent = actualParent.getParentFile() }
                    actualParent = actualParent.getAbsolutePath().minus(&quot;${newRootDir.getAbsolutePath()}/&quot;)
                    line = line.replaceAll(&apos;require_relative\\s+\&apos;(?:\\.\\.\\/)+(.+)\&apos;&apos;, &quot;require &apos;${actualParent ? &quot;${actualParent}/&quot; : actualParent}\$1&apos;&quot;)
                }
                builder.append(line.trim())
                builder.append(&apos;\n&apos;)
            }
            rubyFile.write(builder.toString())
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;A couple of things to point out.  First, the script uses &lt;a href=&quot;http://jruby.org/&quot; target=&quot;_blank&quot;&gt;JRuby&lt;/a&gt; in custom &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; tasks to execute the Ruby-based commands.  Second, the script recursively
walks through each of the installed &lt;a href=&quot;https://rubygems.org/&quot; target=&quot;_blank&quot;&gt;Ruby Gems&lt;/a&gt; to properly normalize any &lt;code&gt;require_relative&lt;/code&gt; statements into absolute paths.  This is necessary as &lt;a href=&quot;http://jruby.org/&quot; target=&quot;_blank&quot;&gt;JRuby&lt;/a&gt; does
not handle relative paths in included &lt;a href=&quot;https://rubygems.org/&quot; target=&quot;_blank&quot;&gt;Ruby Gems&lt;/a&gt; very well (or at all).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;At this point, running &lt;code&gt;./gradlew build&lt;/code&gt; on this project will produce a JAR file containing any Ruby scripts found in &lt;code&gt;src/main/ruby&lt;/code&gt;, as well as any required
&lt;a href=&quot;https://rubygems.org/&quot; target=&quot;_blank&quot;&gt;Ruby Gems&lt;/a&gt; installed by the script.  The next step to use a Ruby-based plugin in a Java application is to use &lt;a href=&quot;http://jruby.org/&quot; target=&quot;_blank&quot;&gt;JRuby&lt;/a&gt; to execute the script.  I&amp;#8217;m not going
to go into all of the details about wiring that up, as the &lt;a href=&quot;http://jruby.org/&quot; target=&quot;_blank&quot;&gt;JRuby&lt;/a&gt; tutorials cover this pretty well.  Instead, I am going to focus on how to extract the
required &lt;a href=&quot;https://rubygems.org/&quot; target=&quot;_blank&quot;&gt;Ruby Gems&lt;/a&gt; that we included in the JAR and make sure that they are available to our Ruby script(s) when &lt;a href=&quot;http://jruby.org/&quot; target=&quot;_blank&quot;&gt;JRuby&lt;/a&gt; executes them.  To accomplish this,
I decided to make use of the &lt;a href=&quot;http://spring.io&quot; target=&quot;_blank&quot;&gt;Spring Framework&lt;/a&gt;&apos;s &lt;code&gt;PathMatchingResourcePatternResolver&lt;/code&gt; to auto-discover the included &lt;a href=&quot;https://rubygems.org/&quot; target=&quot;_blank&quot;&gt;Ruby Gems&lt;/a&gt; and add them to &lt;a href=&quot;http://jruby.org/&quot; target=&quot;_blank&quot;&gt;JRuby&lt;/a&gt;&apos;s load path:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint java language-java&quot;&gt;&lt;code&gt;import java.util.HashSet;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;


import org.jruby.embed.ScriptingContainer;
import org.springframework.core.io.Resource;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;

...

final String pluginName = &quot;test-plugin&quot;;

final PathMatchingResourcePatternResolver patternResolver = new PathMatchingResourcePatternResolver();

final Resource[] dependencyGemResources  = patternResolver.getResources(String.format(&quot;classpath*:/%s/gems/**/*.rb&quot;, pluginName));

final Pattern dependencyGemPattern = Pattern.compile(String.format(&quot;^classpath:\\/%s\\/gems\\/([a-zA-Z\\-\\.0-9_]+)/.*$&quot;, pluginName));

final ScriptingContainer container = new ScriptingContainer();

final Set&amp;lt;String&amp;gt; loadPaths = new HashSet&amp;lt;String&amp;gt;();

// Add the JRuby-provided Ruby 2.0 modules to the load path
loadPaths.add(&quot;classpath:/META-INF/jruby.home/lib/ruby/2.0&quot;);

// Add any required dependency Gems for this plugin to the load path.
for(final Resource resource : dependencyGemResources) {
    final Matcher matcher = dependencyGemPattern.matcher(resource.getURI().toString().replaceAll(&quot;^jar:file:\\/.*\\.jar!(.*)$&quot;, &quot;classpath:$1&quot;));
    if(matcher.find()) {
        final String resourceName = String.format(&quot;classpath:/%s/gems/%s&quot;, pluginName, matcher.group(1));
        if(!loadPaths.contains(resourceName)) {
            loadPaths.add(resourceName);
        }
    }
}

container.setLoadPaths(loadPaths);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The snippet of Java code above makes use of the &lt;code&gt;PathMatchingResourcePatternResolver&lt;/code&gt; from the &lt;a href=&quot;http://spring.io&quot; target=&quot;_blank&quot;&gt;Spring Framework&lt;/a&gt; to scan the classpath and find all &lt;code&gt;.rb&lt;/code&gt; files under the
&lt;code&gt;/&amp;lt;plugin name&amp;gt;/gems&lt;/code&gt; path.  From this list, the URI of each (which is relative to the JAR file) is converted into a classpath-friendly string that &lt;a href=&quot;http://jruby.org/&quot; target=&quot;_blank&quot;&gt;JRuby&lt;/a&gt;
understands and then added to the list of paths for &lt;a href=&quot;http://jruby.org/&quot; target=&quot;_blank&quot;&gt;JRuby&lt;/a&gt; to load prior to execution of the script.  At this point, if a Ruby script is executed via the
&lt;code&gt;ScriptingContainer&lt;/code&gt; with the properly configured load paths, any references to required modules that are packaged in the plugin&amp;#8217;s JAR file will be found and
the script will execute just as if it were run via Ruby.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
            </description>
        </item>
    </channel>
</rss>
