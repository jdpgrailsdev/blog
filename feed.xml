<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>The Flowers Are Still Standing</title>
        <link>http://jdpgrailsdev.github.io/blog/</link>
        <atom:link href="http://jdpgrailsdev.github.io/blog//feed.xml" rel="self" type="application/rss+xml" />
        <description>Jonathan Pearlin's Blog</description>
        <language>en-us</language>
        <pubDate>Tue, 9 Sep 2014 09:14:04 -0400</pubDate>
        <lastBuildDate>Tue, 9 Sep 2014 09:14:04 -0400</lastBuildDate>
        <image>
            <url>http://jdpgrailsdev.github.io/blog//img/robot_devil.png</url>
            <title>Jonathan Pearlin's Blog</title>
            <link>http://jdpgrailsdev.github.io/blog/</link>
        </image>
        <item>
            <title>Avoid Hibernate N+1 Problem with Joins in Spring-Data/JPA</title>
            <link>http://jdpgrailsdev.github.io/blog/2014/09/09/spring_data_hibernate_join.html</link>
            <pubDate>Tue, 9 Sep 2014 00:00:00 -0400</pubDate>
            <guid isPermaLink="false">2014/09/09/spring_data_hibernate_join.html</guid>
            <description>
                    &lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;If you have used &lt;a href=&quot;http://hibernate.org&quot; target=&quot;_blank&quot;&gt;Hibernate&lt;/a&gt; as your ORM for any length of time, you have inevitably run into the
&lt;a href=&quot;http://docs.jboss.org/hibernate/orm/3.3/reference/en-US/html/performance.html#performance-fetching-custom&quot; target=&quot;_blank&quot;&gt;N+1 problem&lt;/a&gt;.  This occurs when
&lt;a href=&quot;http://hibernate.org&quot; target=&quot;_blank&quot;&gt;Hibernate&lt;/a&gt; queries an entity that has a collection of children entities that does not use a &lt;code&gt;JOIN&lt;/code&gt; fetch mode to retrieve the children.  The simple solution
when using &lt;a href=&quot;http://hibernate.org&quot; target=&quot;_blank&quot;&gt;Hibernate&lt;/a&gt; directly is to set the &lt;code&gt;FetchMode&lt;/code&gt; to &lt;code&gt;JOIN&lt;/code&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint java language-java&quot;&gt;&lt;code&gt;User user = (User) session.createCriteria(User.class)
                .setFetchMode(&quot;permissions&quot;, FetchMode.JOIN)
                .add( Restrictions.idEq(userId) )
                .uniqueResult();&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;However, if you are using &lt;a href=&quot;http://www.oracle.com/technetwork/java/javaee/tech/persistence-jsp-140049.html&quot; target=&quot;_blank&quot;&gt;JPA&lt;/a&gt; on top of &lt;a href=&quot;http://hibernate.org&quot; target=&quot;_blank&quot;&gt;Hibernate&lt;/a&gt;, there is no way to set the &lt;code&gt;FetchMode&lt;/code&gt; used by &lt;a href=&quot;http://hibernate.org&quot; target=&quot;_blank&quot;&gt;Hibernate&lt;/a&gt; to &lt;code&gt;JOIN&lt;/code&gt;.  In fact, &lt;a href=&quot;http://www.oracle.com/technetwork/java/javaee/tech/persistence-jsp-140049.html&quot; target=&quot;_blank&quot;&gt;JPA&lt;/a&gt; only
supports two types of fetching:  &lt;code&gt;EAGER&lt;/code&gt; and &lt;code&gt;LAZY&lt;/code&gt;.  Luckily, there is another &lt;a href=&quot;http://www.oracle.com/technetwork/java/javaee/tech/persistence-jsp-140049.html&quot; target=&quot;_blank&quot;&gt;JPA&lt;/a&gt; API that can be used to address this problem:  &lt;a href=&quot;http://projects.spring.io/spring-data-jpa/&quot; target=&quot;_blank&quot;&gt;Spring Data JPA&lt;/a&gt;.  The
&lt;a href=&quot;http://projects.spring.io/spring-data-jpa/&quot; target=&quot;_blank&quot;&gt;Spring Data JPA&lt;/a&gt; library provides a &lt;a href=&quot;http://spring.io/blog/2011/04/26/advanced-spring-data-jpa-specifications-and-querydsl/&quot; target=&quot;_blank&quot;&gt;Domain Driven Design Specifications&lt;/a&gt;
API that allows you to control the behavior of the generated query.  This will allow you to tweak things such as the fetch mode to ensure the proper instruction
is passed to &lt;a href=&quot;http://hibernate.org&quot; target=&quot;_blank&quot;&gt;Hibernate&lt;/a&gt; to address the N+1 problem.  I&amp;#8217;m not going to go into a bunch of details on how to use the &lt;code&gt;JpaSpecificationExecutor&lt;/code&gt;, as the &lt;a href=&quot;http://projects.spring.io/spring-data-jpa/&quot; target=&quot;_blank&quot;&gt;Spring Data JPA&lt;/a&gt;
documentation does a pretty good job of covering it.  What is more important is how to control the fetch mode using it:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint java language-java&quot;&gt;&lt;code&gt;final long userId = 1;

final Specification&amp;lt;User&amp;gt; spec = new Specification&amp;lt;User&amp;gt;() {
    @Override
    public Predicate toPredicate(final Root&amp;lt;User&amp;gt; root, final CriteriaQuery&amp;lt;?&amp;gt; query, final CriteriaBuilder cb) {
        query.distinct(true);
        root.fetch(&quot;permissions&quot;, JoinType.LEFT);
        return cb.equal(root.get(&quot;id&quot;), userId);
     }
};

List&amp;lt;User&amp;gt; users = userRepository.findAll(spec);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;There are two important pieces of the example above.  The first is the setting of the &lt;code&gt;distinct&lt;/code&gt; flag on the query to ensure that the proper (unique) results are returned as
a result of the join.  The second is the addition of a &lt;code&gt;fetch&lt;/code&gt; hint to the root entity, telling the specification to perform a left join of the root to the entity mapped
by the &quot;permissions&quot; field of the root entity.  This ensures that &lt;a href=&quot;http://hibernate.org&quot; target=&quot;_blank&quot;&gt;Hibernate&lt;/a&gt; will now perform a join instead of N+1 queries to fetch the root entity and its associated
children.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
            </description>
        </item>
        <item>
            <title>Ensure Order of Task Execution between Gradle Sub-Projects</title>
            <link>http://jdpgrailsdev.github.io/blog/2014/09/02/gradle_subtask_dependson.html</link>
            <pubDate>Tue, 2 Sep 2014 00:00:00 -0400</pubDate>
            <guid isPermaLink="false">2014/09/02/gradle_subtask_dependson.html</guid>
            <description>
                    &lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;One of the great things (IMHO) about &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; is that it does a pretty good job of choosing sane conventions.  That being said, one place that seems to not always
be a great choice is &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt;&apos;s convention to visit sub-projects in alpha-numerical order.  Let&amp;#8217;s say that you have the following project structure:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;root
 |_ A
 |_ B
    |_ C
    |_ D
 |_ E&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Based on the alpha-numerical ordering, you would probably expect &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; to visit the projects in the following order:  A, B, B:C, B:D, E.  However, this is not the case.
&lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; will visit the sub-projects in alpha-numerical order, within each level.  What you end up with is:  A, B, E, B:C, B:D.  Normally, this probably isn&amp;#8217;t a big deal.
This does become a big deal when one of those sub-projects builds a distribution that needs to include output from all of the other sub-projects.  Such is the case when
building a fully-repackaged, executable JAR file with &lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt;.  The repackaged JAR built by the
&lt;a href=&quot;http://docs.spring.io/spring-boot/docs/current/reference/html/build-tool-plugins-gradle-plugin.html&quot; target=&quot;_blank&quot;&gt;Spring Boot Gradle Plugin&lt;/a&gt; includes all dependency JAR files
required to execute the application.  Let&amp;#8217;s suppose in our example above, the sub-project E&amp;#8217;s &lt;code&gt;build.gradle&lt;/code&gt; script includes the following dependency block:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;dependencies {
    compile module(&apos;:A&apos;)
    compile module(&apos;:B:C&apos;)
    compile module(&apos;:B:D&apos;)
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;What we would like to happen is that when we build project &quot;E&quot;, the JAR file should include the JAR&amp;#8217;s produced by building &quot;A&quot;, &quot;B:C&quot;, and &quot;B:D&quot;.  What actually happens is
that only &quot;A&quot;&apos;s JAR gets included, because of the ordering outlined earlier in this post.  The way to correct this behavior and to ensure that all other sub-projects build
their JAR files prior to &quot;E&quot;&apos;s JAR task executing is to add the following to &quot;E&quot;&apos;s &lt;code&gt;build.gradle&lt;/code&gt; script:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;// Ensure that all other JARs are built before the service is packaged.
project.tasks.jar.dependsOn(rootProject.getSubprojects().findAll { subproject -&amp;gt; subproject.name != project.name }.collect { subproject -&amp;gt; &quot;${subproject.getPath()}:build&quot; })&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The logic above finds every other sub-project in the project and adds that sub-project&amp;#8217;s &quot;build&quot; task as a dependency that first must execute before the current project&amp;#8217;s
JAR task can execute.  This ensures that all other projects have built their JAR files before &lt;a href=&quot;http://projects.spring.io/spring-boot/&quot; target=&quot;_blank&quot;&gt;Spring Boot&lt;/a&gt; can create the re-packaged JAR.  You can apply this same trick to
any other scenario where the execution of tasks in other sub-projects (regardless of depth) must occur before a certain sub-project&amp;#8217;s task(s).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
            </description>
        </item>
        <item>
            <title>Execute Gradle Tasks Based on Other Tasks</title>
            <link>http://jdpgrailsdev.github.io/blog/2014/08/26/gradle_dependent_tasks.html</link>
            <pubDate>Tue, 26 Aug 2014 00:00:00 -0400</pubDate>
            <guid isPermaLink="false">2014/08/26/gradle_dependent_tasks.html</guid>
            <description>
                    &lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;As discussed in a previous post, &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; supports multiple ways to perform incremental builds, such as caching based on task inputs, the use of the
&lt;a href=&quot;http://www.gradle.org/docs/current/javadoc/org/gradle/api/tasks/TaskOutputs.html#upToDateWhen(groovy.lang.Closure)&quot; target=&quot;_blank&quot;&gt;upToDateWhen&lt;/a&gt; closure on a
task&amp;#8217;s outputs or the use of the task&amp;#8217;s &lt;code&gt;onlyIf()&lt;/code&gt; method to control execution, to name a few.  Sometimes, however, you want a task to only execute if another
cachable task has executed.  For instance, maybe you want to create an archive of some generated source, but only if the source has been updated/re-generated.
One such way to do this is to make use of the &lt;a href=&quot;http://www.gradle.org/docs/current/groovydoc/org/gradle/api/Task.html#getDidWork()&quot; target=&quot;_blank&quot;&gt;getDidWork()&lt;/a&gt;
method of the task to determine if the task actually executed or was skipped/up-to-date:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;class CustomTask extends DefaultTask {

    @TaskAction
    void doSomething() {
        if(project.tasks.getByName(&apos;otherTask&apos;).getDidWork()) {
            // Do this task&apos;s work here!
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;By using the &lt;code&gt;getDidWork&lt;/code&gt; method on the other task to determine if it executed, we can avoid having to rely upon the input/output of the task to determine if
the downstream task should execute, thus giving us better control over what triggers the tasks in our project.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
            </description>
        </item>
        <item>
            <title>Gradle, Task Caching, Tests and Jenkins</title>
            <link>http://jdpgrailsdev.github.io/blog/2014/08/19/gradle_tests_jenkins.html</link>
            <pubDate>Tue, 19 Aug 2014 00:00:00 -0400</pubDate>
            <guid isPermaLink="false">2014/08/19/gradle_tests_jenkins.html</guid>
            <description>
                    &lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;One of the nice features of &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; is the task execution caching, which prevent tasks whose inputs/outputs have not changed since the last successful execution from
executing in order to speed up build times.  Sometimes, however this causes issues when integrating your &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; build into other systems.  I ran into one such issue
when building a &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; application from &lt;a href=&quot;http://jenkins-ci.org/&quot; target=&quot;_blank&quot;&gt;Jenkins&lt;/a&gt;.  The &lt;a href=&quot;http://jenkins-ci.org/&quot; target=&quot;_blank&quot;&gt;Jenkins&lt;/a&gt; build job is configured to publish the results of the &lt;code&gt;test&lt;/code&gt; task (the test reports output by &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt;).
It did not occur to me that if I did not invoke the &lt;code&gt;clean&lt;/code&gt; task and let &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; only re-generate the test reports if any of the compiled code had changed (other file changes
to the project would trigger the CI build) that &lt;a href=&quot;http://jenkins-ci.org/&quot; target=&quot;_blank&quot;&gt;Jenkins&lt;/a&gt; would fail the build due to stale test reports.  However, that is exactly what happened:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;BUILD SUCCESSFUL

Total time: 15.323 secs
Build step &apos;Invoke Gradle script&apos; changed build result to SUCCESS
Test reports were found but none of them are new. Did tests run?
For example, /var/jenkins/jobs/test-job/workspace/build/test-results/TEST-com.example.TestSpec.xml is 12 hours 15 minutes old

Build step &apos;Publish JUnit test result report&apos; changed build result to FAILURE
Finished: FAILURE&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;By not cleaning out the previously compiled code, the caching mechanism for the &lt;code&gt;test&lt;/code&gt; task kicked in and left the previous test results in place, as it properly detected that
nothing had changed and therefore is no need to re-run the tests.  However, Jenkins apparently bases its ability to publish the results of the tests based on a timestamp and not
just the presence of the tests results in the directory specified in the job&amp;#8217;s configuration.  One easy fix is to always run the &lt;code&gt;clean&lt;/code&gt; task, but that eliminates a lot of &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt;&apos;s
performance enhancements around only running task incrementally, based on their inputs/outputs.  Another option is to add the &lt;code&gt;--rerun-tasks&lt;/code&gt; option, which effectively does the same
thing as the &lt;code&gt;clean&lt;/code&gt; task, except it doesn&amp;#8217;t remove any artifacts&amp;#8201;&amp;#8212;&amp;#8201;it just simply forces &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; to run each task regardless of the caching status.  Neither of these options really
get us what we want.  One other alternative is to make use of the &lt;code&gt;upToDateWhen&lt;/code&gt; configuration closure on a tasks declared outputs to control caching on a per-task basis:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;    // Always execute the tests -- needed for Jenkins to be happy
    test.outputs.upToDateWhen { false }&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The example above directs &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; to always run the &lt;code&gt;test&lt;/code&gt; task regardless of what the task cache tells &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; about it.  This gives us fine grained control over which tasks
that we want to take advantage of caching and which ones we want to always run.  By adding the one line above to my project&amp;#8217;s &lt;code&gt;build.gradle&lt;/code&gt; script, I was able to make &lt;a href=&quot;http://jenkins-ci.org/&quot; target=&quot;_blank&quot;&gt;Jenkins&lt;/a&gt;
happy with always providing up-to-date unit tests results, regardless of which files (source or otherwise) have changed in my project.  This also means that &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; will take
advantage of task caching for other tasks in the project (such as compilation, packaging, etc), which helps to reduce build time.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
            </description>
        </item>
        <item>
            <title>Dynamically Build JavaExec Classpath from BuildScript Dependencies in Gradle</title>
            <link>http://jdpgrailsdev.github.io/blog/2014/08/12/gradle_javaexec_classpath.html</link>
            <pubDate>Tue, 12 Aug 2014 00:00:00 -0400</pubDate>
            <guid isPermaLink="false">2014/08/12/gradle_javaexec_classpath.html</guid>
            <description>
                    &lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Recently, I have been working on a few &lt;a href=&quot;http://gradle.org&quot; target=&quot;_blank&quot;&gt;Gradle&lt;/a&gt; plugins that use the &lt;a href=&quot;http://www.gradle.org/docs/current/dsl/org.gradle.api.tasks.JavaExec.html&quot; target=&quot;_blank&quot;&gt;Gradle JavaExec Task&lt;/a&gt;
to execute a Java main class from within the plugin.  This is pretty straightforward and not at all interesting.  However, in testing the plugin, I realized that I did not
want to expose the required dependencies needed to run the main class outside of the plugin.  If I did, I would require each project that applies my plugin to list the
dependencies in its &lt;code&gt;dependencies&lt;/code&gt; block.  This is obviously a leaky abstraction, so I decided to see if I could programmatically set the classpath of the &lt;a href=&quot;http://www.gradle.org/docs/current/dsl/org.gradle.api.tasks.JavaExec.html&quot; target=&quot;_blank&quot;&gt;Gradle JavaExec Task&lt;/a&gt;
to us use the plugin&amp;#8217;s dependencies:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;task generate(type: JavaExec) {
    main = &apos;com.example.Generator&apos;
    args = [&apos;arg1&apos;, &apos;arg2&apos;]
    classpath = buildscript.configurations.classpath
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In the example above, the task&amp;#8217;s classpath is set to the classpath created by the &lt;code&gt;buildscript&lt;/code&gt; DSL, which includes my plugin dependency and all of its transitive dependencies (unless
you disable transitive resolution when you define the plugin dependency).  This worked great until I used my plugin as part of a multi-module project, where the plugin dependency
is declared and applied in the root project, but the task is executed on the sub-project.  What happened is that the above example only loaded the build script classpath for
the current project (the sub-project), which did not have the plugin dependency on its classpath (apparently, the build script classpath is not additive/transitive).  I addressed
this by writing a little recursive function to traverse up the project tree and add the dependencies from each build script:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;task generate(type: JavaExec) {
    main = &apos;com.example.Generator&apos;
    args = [&apos;arg1&apos;, &apos;arg2&apos;]
    classpath = files(getClasspath(project))
}

private List&amp;lt;File&amp;gt; getClasspath(project, classpath=[]) {
    if(project == null || project == project.rootProject) {
        classpath
    } else {
        classpath.addAll(project.buildscript.configurations.classpath.getFiles())
        getClasspath(project.rootProject, classpath)
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The above example starts with the current project, adds its build script dependencies to the classpath and then recursively looks at the project&amp;#8217;s root project.  This continues
until the project does not have a root project or the root project is the project itself.  The result is then converted to a &lt;code&gt;FileCollection&lt;/code&gt; and the classpath is set, ensuring
that the &lt;a href=&quot;http://www.gradle.org/docs/current/dsl/org.gradle.api.tasks.JavaExec.html&quot; target=&quot;_blank&quot;&gt;Gradle JavaExec Task&lt;/a&gt; has the dependencies provided by the custom plugin.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
            </description>
        </item>
    </channel>
</rss>
